[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V17.00 P2 E1 W17.00 T1426984322 M17.00 I0 O0
# Post Name             : Somec_Excel
# Customer              : Future Test
# Product                   : LATHE
# Machine Name          : Somec Excel HTC
# Control Name          : Mitsubishi Meldas 64
# Description               : LATHE C-AXIS POST, Index Only
# Mill/Turn                 : YES
# 4-axis/Axis subs.     : NO
# 5-axis                        : NO
# Subprograms           : YES
# Canned Cycles         : YES
# Executable                : MP 10.0
# Associated Post       : Lathe_master 04.02.08
# Encryption                : none
# Expiration                : unlimited
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# Associated File List$
# Somec_Excel.control
# Somec_Excel.lmd
# Somec_Excel.pst
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# MLC 05/29/08 - update for multi spindle single turret Fanuc style lathe
#                              and is switchable for single spindle Fanuc style lathes
#                         update misc ops clamping
# MLC 06/06/08 - synced with my latest revision, jcw
# MLC 07/29/08 - initial configuraiton for Future Test Somec_meldas HTC, jcw
# MLC 08/05/08 - make changes based on customer request, jcw
# MLC 08/09/08 - update output per samples, jcw
# MLC 10/20/08 - update thread_address to output "F" for thread feed, jcw
# MLC 10/22/08 - update G50 definition to G92, jcw
# MLC 10/23/08 - update max spindle speed,fixed double line numbers, jcw
# MLC 01/09/09 - changed setting for arc direction in scase strings, jcw
# MLC 04/03/09 - updated ltlchg0$, mtlchg0$, jcw
# MLC 04/06/09 - add bar stop Z value prompt, jcw
# MLC 07/07/09 - update pprep$ parameter error, jcw
# MLC 07/13/09 - update peck1$ fmt statment from 16 to 2, jcw
# MLC 06/03/10 - update post output per customer request, jcw
#                         add live tool comments, jcw      
# MLC 06/04/10 - update mill spindle control, jcw
# MLC 06/21/10 - update rotary drilling positioning, added M05 to disable C, jcw
#                         added inc_r switch for drilling R value output  
#                         updated live tool control, mtlchg$
# MLC 05/11/11 - update pindex, pindexdrl, post blocks, jcw
# MLC 09/09/15 - updated per customer request, jjm
#
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
#
# This post supports sub spindle lathes that use the misc. settings for the pickoff
# or regular single spindle lathes set the sub_spdl switch under general settings
#
#######          MILL/TURN FUNCTIONS SUPPORTED BY THIS POST          #######
#
# This post supports Generic Fanuc code output for mill/turn lathes.
# It is designed to support the features of Mastercam X.
#
## NEW FEATURES FOR X
# - Machine definition, control definition and toolpath group parameter read sections added.
# - Variable initialization with CD_VAR are read directly from CD.  Changing these initial values
#     in the post will not effect output.  These values are only processed during the update post routine.  
# - Variable initialization with SET_BY_MD or SET_BY_CD are overwritten in this post by parameter or
#     variable settings from MD or CD.
# - Enhanced tool information - Added switch for tool comments (see tool_info)
# - Supports X comments including machine name, group name and group comment output (see pcomment2)
# - Additional date, time and data path output options (see pheader)  
# - Support for 10 additional canned text options for X
# - Decimal support for sequence number output (set "Increment sequence number" in CD to a decimal value
#     for output.  I.E. "Increment sequence number" = .5, "Start sequence number" = 10 : N10, N10.5, N11, N11.5, etc...)
# - Switch for output of M00 or M01 at tool change (3 position switch, off, M00, M01 - see prog_stop)
# - Support for seperate XY, XZ and YZ plane/arc variables (see Arc page in CD)
# - Support for X style coolant.  Allows up to 10 different coolants to be turned on/off before, with, or after like
#     canned text.  Coolant output is handled by "coolant" variable and string selector for V9 style coolant,
#     "coolantx" variable and string selector for X style coolant.
#-------------------------------------------------------------------------------------------------------------------------------------------
# Following Misc. Integers are used:
#
# mi4 - Canned conversion cycle type selection:   (mill only)
#       Mill-
#       Activates milling axis conversation canned cycles (G107 or G112).
#       1 activates the cycle.  Post will change rapid moves to high feed linear moves.
#
# mi5 - Spindle Synch
#       0 = Off
#       1 = On
#
# mi6 - Feed/Rev Output   (mill)
#       0 = Off
#       1 = On
#
# mi7 - Clamp Code Override     (mill only)
#       0 = Default post decision
#       1 = Force Full Clamp
#       2 = Force Brake / Mid-Clamp
#       3 = Off
#
# mr1 - Initial G58 B Position
#           used for pickoff
#
# mr2 - Feed Onto Bar distance
#           used for pickoff
#
# mr3 - Stock Advance distance
#           used for pickoff
#
# mr4 - Sub Spindle Orientation
#           used for pickoff
#
#Canned text:
#  Entering cantext within Mastercam allows the following functions to
#  enable/disable.
#  cantext value:
#  1 = Program Stop =  output the "M00" stop code
#  2 = Optional Stop = output the "M01" optional stop code
#  3 = Block Delete on = turn on block delete codes in NC lines
#  4 = Block Delete off = turn off block delete codes in NC lines
#  5 = Return Tailstock =  output the code to retract the tail stock
#  6 = Advance Tailstock =  output the code to advance the tail stock
#  7 = Return Chute =  output the code to retract the chute
#  8 = Advance Chute =  output the code to advance the chute
#  9 = Exact Stop on = turn on the exact stop code in the NC line
#  10 = Exact Stop off = turn off the exact stop code in the NC line
#  11 to 99 output the value selected
#
#TURN TOOLPATHS:
#Lathe canned cycles:
# Supports lathe canned turning cycles through Mastercam.  This post
# is configured to process them.
#
#MILL TOOLPATHS:
#Mill Layout:
# The term "Reference View" refers to the coordinate system associated
# with the Mill Top view (Alt-F9, the upper gnomon of the three displayed).
# Create the part drawing with the the axis of rotation along the X axis
# of the "Mill Reference View" with the face of the part toward the side
# view (Mill Reference View X plus direction).  The Y plus axis of the
# Mill Reference View indicates the position on the part of C zero
# (View number 3).  The right or left side view are the only legal views
# for face milling.  The view number 3 rotated about the X axis as a
# "single axis rotation" are the only legal views for cross milling
# except for axis substitution where the top view is required.
# Rotation around the part is positive in the CCW direction when viewed
# from the side view.
# (The Chook 'CVIEW' should be used for creating milling tool plane and
# construction plane selections, C axis toolpaths in lathe perform
# this function automatically).
#NOTICE: View number 3 always indicates the location for C zero.  Milling
#        with a turret below the centerline indicates C at 180 degrees.
#
#Mill canned cycles:
#Cylindrical interpolation, G107 canned cycle:
# Cylindrical interpolation is created with axis substitution only.
# Use the Caxis/C_axis Contour toolpath.  Create the geometry from
# view number 4 if the rotation of C axis is CCW.  This prevents producing
# a mirror image.  Wrapped and unwrapped geometry are broken and arcs are
# lost so it is better to create flattened geometry.  Set the parameters
# in Rotary Axis not to 'unroll' and set the correct diameter.
# Use View number 3 as the C0 location.  Set mi4 to activate!
#
#Polar interpolation, G112 canned cycle:
# Polar interpolation is active only for face cutting (Right or Left).
# Use the Caxis/Face Contour toolpath.  Create geometry for the lead in
# and lead out with the start and end position on the View number 3 tool
# axis.  All paths must start and end at the 'C0'location for output to
# be correct.  Chain the entire geometry without using Mastercam leads.
# Set mi4 to activate!
#
#Axis substitution:
# View number 3 is the C zero location on the part and corresponds to the
# Y zero position of the "Mill Reference View".  Positions are wrapped
# from and to the diameter of the part as CCW for the Y positive direction.
# If geometry is drawn from View number 4 (Bottom), it is correct for the
# wrap/unwrap on the diameter.  The radius of the specified diameter is
# added to the Z position in the post.  The Y axis is the only axis to
# be converted with mill/turn.
#
#Simultaneous 4 Axis (11 gcode):
# Full 4 axis toolpaths can be generated from various toolpaths under the
# 'multi-axis' selection (i.e. Rotary 4 axis). All 5 axis paths are
# converted to 4 axis paths where only the angle about the rotation axis
# is resolved. Use View number 3 for the toolplane with all 'multi-axis'.
# 4 and 5 axis toolpaths are converted assuming cross machining only!
#
#Y axis output and machining over part center:
# Output Y axis motion by setting 'Rotary axis/Y axis' in the NC
# parameter page.  This requires a valid Axis Combination in your machine defintion.
# y_axis_mch is set from the axis combination.
# Set 'Rotary axis/Y axis' in a machine with no Y axis (y_axis_mch = 0)
# to force linear/circular position moves in the XZ plane (g18).
# This allows machining over the part center.
#Caution: The machining must stay in the XZ plane at a Y fixed value
# when y_axis_mch = zero because no C (other than the Tplane) or
# Y positions are output!!!  This occurs when selecting C_axis/Cross
# Contour without 'y_axis_mch'.  Use Mill toolpaths for cross profiling.
#
#NOTICE: Milling through the part center with a linear move requires the
#        geometry be broken at the centerline.  Milling through the part
#        center with an arc move in the G18 plane, no Y axis and on the
#        negative side of X, reverses only the arc direction and I sign.
#
#Additional Notes:
# 1) G54 calls are generated where the work offset entry of 0 = G54,
#    1 = G55, etc.
# 2) Metric is applied from the NCI met_tool variable.
# 3) The Tplane angle is added to polar conversion and rotary paths.
# 4) The variable 'absinc' is now pre-defined, set hard_mi2 (Misc. Integer) for
#    the 'top level' absolute/incremental program output.  Subprograms are
#    updated through the Mastercam dialog settings for sub-programs.
# 5) Lathe disables coordinate mirror and rotate subprograms.
# 6) When creating tools the diameter/radius should end as even numbers
#    relative to the machine precision. EX. Enter 1.0002 dia. and not
#    1.0001 dia. with a machine accuracy of .0001.
# 7) Transform subprograms are intended for use with G54... workshifts.
# 8) Incremental motion at a toolchange is calculated from the values
#    entered for home position.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and program switches
# --------------------------------------------------------------------------
m_one       :  -1   #Define constant
zero        : 0     #Define constant
one         : 1     #Define constant
two         : 2     #Define constant
three       : 3     #Define constant
four        : 4     #Define constant
five        : 5     #Define constant
c9k         : 9999  #Define constant

log_file         : 0     # Output Error File 0=No, 1=Yes
bug4$        : 1     #Append NCI line no. to each NC line?
whatno$      : yes$  #Do not perform whatline branches? (leave as yes)
linktolvar$  : 0     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 0     #Associate X plane specific variables to V9- variable?
linklvar$    : 0     #Associate X lathe specific variables to V9- variable?

skp_lead_flgs$ : 1   #Do NOT use v9 style contour flags
get_1004$    : 0     #Find gcode 1004 with getnextop?
rpd_typ_v7$  : 0     #Use Version 7 style contour flags/processing?
strtool_v7$  : 2     #Use Version 7+ toolname?
tlchng_aft$  : 2     #Delay call to toolchange until move line
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table
cc_1013$     : 1     #Read cc_pos on the 1013 line, lathe

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
utxref          : 0     # Upper Turret X Referance Position
utzref          : 6.    # Upper Turret Z Referance Position

# Rem Out The Next Two Assignments to Output utxref/utzref values
#utxref = xh$           # Global Upper Turret X Home Assignment
#utzref = zh$           # Global Upper Turret Z Home Assignment

sub_spdl        : 0     #Sub Spindle Machine 0=no, 1=yes

home_type    : 2     #Work coordinate system: (home_type)
                            # -1 = Reference return / Tool offset positioning.
                            # 0 = G50 with the X and Z home positions.
                            # 1 = X and Z home positions.
                            # 2 = WCS of G54, G55.... based on Mastercam settings.

org_x_pos   : 1     # Output Original X Postion On Canned Cycle 0=no, 1=yes

hard_mi2        : 0     # Absolute or Incremental  0 = absolute, 1 = incremental

hard_mi3        : 2     # Select Reference Point Return:   0 = G28, 1 = G30, 2 = G53

t_plus          : 10   # Add To Offset For Sub Spindle, Work All Tools

drl_offset      : 1     # Drill Tool Offsets  0=Single, 1=Both

lock_out_y    : 1     # Lock Out Y Axis From MD Setting

mult_spd_tl   :  1  # Multi Spindle Tool List 0=no, 1=yes

met_out         : 0     # Output Metric Code 0=no 1=yes

sp_select       : 0     # Output Spindle Selecter G Code 0=no, 1=yes

mctcmnt     : 0     # Mastercam Tool Comment  0=no, 1=yes

b_prompt        : 1     # Prompt for Bar feeder 0=no, 1=yes

force_wcs    : yes$     # Force WCS output at every toolchange?

first_wcs       : yes$  # Output First WCS Only

progname$    : 1     # Use uppercase for program name

css_start_rpm : yes$   # Do direct RPM spindle start prior to CSS?

css_end_rpm  : no$   # Do direct RPM spindle prior to Retract?

prog_stop    : 1      # Program stop at toolchange: 0=None, 1=M01, 2 = M00

tool_info    : 1          # Output tool information?
                                # 0 = Off - Do not output any tool comments or tool table
                                # 1 = Tool comments only
                                # 2 = Tool table only
                                # 3 = Tool comments and tool table

use_pitch    : 0        #0 = Use feed for tapping (force Feed/Min), 1 = Use pitch for tapping (force Feed/Rev)

rigid_tap    : 1      # 0 = Floating tap output
                            # 1 = Rigid tap output (Set parameter 5200 bit 0 to 1 for rigid)
                            # (Set M code for rigid tap in parameter 5210)

tap_feed     : 1    # 0 = 2/1 (in/mm) decimal places, 1 = 4/3 (in/mm) decimal places 

thread_address : 0   # Thread pitch address for lathe threading, 0 = Use F, 1 = Use E

use_clamp    : 0     # 0 = No, 1 = Clamp

use_brake    : 0     # 0 = No, 1 = Brake

lathe_stop   : 1     # Stop lathe spindle on lathe tool change? 0 = no, 1 = yes 

drop_offset  : 0     # Drop offset at end of tool? 0 = no, 1 = yes

tseqno       : 0     # Output sequence number at toolchanges when omitseq = yes
                           # 0=off, 1=seq numbers match toolchange number, 2=seq numbers match tool number
g54g55       : 1     # 0 = Use Mcam Work Offset Logic, 1 = Force G54 for main spindle and G55 for sub spindle

c_resolution : 0.001    # Set your C-axis resolution.  This is used for deg/min feed calcs 
                                    # Post must only enter pfclc_deg_inv if C motion >= to the resolution of the axis output occurs

checkyflg    : yes$  # Check Y movement only once for error

cwind        : 1     # 0 = No, always start the calc from 0, 1 = Yes, allow C-axis winding for axis subsitution (start at closest rev)

inc_r         : 1     # R plane is incremental from initial height live drilling 0 = No, 1 = Yes

#Interpolation Output Settings
g107crad      : 0       # 0 = radius, 1 = diameter
g112address   : 1    # 0 = Y, 1 = C

# --------------------------------------------------------------------------
# Machine Specific Settings
# --------------------------------------------------------------------------
#Machine axis switches, initial
y_axis_mch  : no$   #SET_BY_MD - Machine has a Y axis, 0=no, 1=yes - Set based on Axis Combination in MD
old_new_sw  : 1     #Switch old (6T), new (0T+) cycle formats, 0=old, 1=new
wcs_origin  : 0     #Always use the WCS origin for coordinates
dia_mult    : 2     #Multiplier for output on X axis (Neg. switches sign of X)
y_mult      : 1     #Multiplier for output on Y axis (Neg. switches sign of Y)
z_mult      : 1     #Multiplier for output on Z axis (Neg. switches sign of Z)
dia_shift   : 0     #Shift for output on X axis, radial entry
y_shift     : 0     #Shift for output on Y axis
z_shift     : 0     #Shift for output on Z axis
map_home    : yes$   #Use home positions as entered or map to machine axis

#C axis and Index switches
str_cax_abs : "C"     #String address for absolute rotary axis
str_cax_inc : "H"     #String address for incremental rotary axis
str_index   : "C"     #String address for indexer
frc_cinit   : 1     #Force C axis reset at toolchange
c_shift     : 0     #Shift for output on bottom turrets with C axis
ctol        : 270   #Tolerance in deg. of inc. move before 'rev' flag changes
ctable      : 1     #Degrees for each index step with indexing spindle
ixtol       : 0.01  #Tolerance in deg. for index error
maxfrdeg    : 2000  #Limit for feed in deg/min
frdegstp    : 10    #Step limit for rotary feed in deg/min

#Spindle switches and values
use_gear    : 0      #Output gear selection code, 0=no, 1=yes
cool_w_spd  : 0      #Output coolant with spindle code, 0=no, 1=yes - only available with V9 coolant option in MD
max_speedl0 : 5000   #Maximum spindle speed (lathe), Bottom turret/Left spindle
min_speedl0 : 20     #Minimum spindle speed
max_speedm0 : 2500   #Maximum spindle speed (mill)
min_speedm0 : 50     #Minimum spindle speed
max_speedl1 : 5000   #Maximum spindle speed (lathe), Top turret/Left spindle
min_speedl1 : 20     #Minimum spindle speed
max_speedm1 : 2500   #Maximum spindle speed (mill)
min_speedm1 : 50     #Minimum spindle speed
max_speedl2 : 5000   #Maximum spindle speed (lathe), Bottom turret/Right spindle
min_speedl2 : 20     #Minimum spindle speed
max_speedm2 : 2500   #Maximum spindle speed (mill)
min_speedm2 : 50     #Minimum spindle speed
max_speedl3 : 5000   #Maximum spindle speed (lathe), Top turret/Right spindle
min_speedl3 : 20     #Minimum spindle speed
max_speedm3 : 2500   #Maximum spindle speed (mill)
min_speedm3 : 50     #Minimum spindle speed

#Machining position turret/spindle settings
# Switch strings based on turret position top/bottom-left/right and cut type.
# Turret position is based on the Mastercam settings (see lathtype).
# Strings are re-assigned for output in the routine psw_str_mult.
# The string variable sw_string holds the place position value to determine
# how to assign the strings.  Planes are relative to the view from Mastercam.
# Assign the 17 digit string following the alpha columns below:
# A - C axis, 1 = axis winds, 2 = axis signed, 3 = indexer
# B - Spindle direction, 0 = normal, 1 = reverse
# C - Plane 0 arc/comp, 0 = normal, 1 = switch
# D - Plane 1 arc/comp, 0 = normal, 1 = switch
# E - Plane 2 arc/comp, 0 = normal, 1 = switch
# F - Plane 0, 0 = G17, 1 = G19, 2 = G18
# G - Plane 1, 0 = G17, 1 = G19, 2 = G18
# H - Plane 2, 0 = G17, 1 = G19, 2 = G18
# Decimal (required)
# I - Plane 0, X axis, 0 = normal, 1 = switch sign from basic
# J - Plane 0, Y axis, 0 = normal, 1 = switch sign from basic
# K - Plane 0, Z axis, 0 = normal, 1 = switch sign from basic
# L - Plane 1, X axis, 0 = normal, 1 = switch sign from basic
# M - Plane 1, Y axis, 0 = normal, 1 = switch sign from basic
# N - Plane 1, Z axis, 0 = normal, 1 = switch sign from basic
# O - Plane 2, X axis, 0 = normal, 1 = switch sign from basic
# P - Plane 2, Y axis, 0 = normal, 1 = switch sign from basic
# Q - Plane 2, Z axis, 0 = normal, 1 = switch sign from basic
use_only_tl : 0 #Use only Top turret/Left spindle settings (below) 
                            #for all Mastercam turret/spindle selections
                            #When configuring for multi-spindle/turret set to 0

#Columns-    ABCDEFGH.IJKLMNOPQ #Turret/Spindle            #Path Type
scase_tl_c1  : "10000222.000000000"  #Top turret/Left spindle, Turning cut
scase_tl_c2  : "10000012.000000000"  #Top turret/Left spindle, Right Face cut
scase_tl_c_2 : "10110012.000000000"  #Top turret/Left spindle, Left Face cut
scase_tl_c3  : "10010102.000000000"  #Top turret/Left spindle, Cross cut (cuttype = 3)
scase_tl_c3r : "10001102.000000000"  #Top turret/Left spindle, Reverse Cross cut (cuttype = -3)
scase_tl_c4c : "10000222.000000000"  #Top turret/Left spindle, Y axis subs. Cycle
scase_tl_c4  : "10000122.000000000"  #Top turret/Left spindle, Y axis subs.
scase_tl_c5  : "10000222.000000000"  #Top turret/Left spindle, Multisurf Rotary

#Columns-    ABCDEFGH.IJKLMNOPQ
scase_bl_c1  : "10111222.000000000"  #Bottom turret/Left spindle, Turning cut
scase_bl_c2  : "10111222.000000000"  #Bottom turret/Left spindle, Right Face cut
scase_bl_c_2 : "10111222.000000000"  #Bottom turret/Left spindle, Left Face cut
scase_bl_c3  : "10011222.000000000"  #Bottom turret/Left spindle, Cross cut (cuttype = 3)
scase_bl_c3r : "10011222.000000000"  #Bottom turret/Left spindle, Reverse Cross cut (cuttype = -3)
scase_bl_c4c : "10000222.000000000"  #Bottom turret/Left spindle, Y axis subs. Cycle
scase_bl_c4  : "10000222.000000000"  #Bottom turret/Left spindle, Y axis subs.
scase_bl_c5  : "10000222.000000000"  #Bottom turret/Left spindle, Multisurf Rotary

#Columns-    ABCDEFGH.IJKLMNOPQ
scase_tr_c1  : "10000222.000000000"  #Top turret/Right spindle, Turning cut
scase_tr_c2  : "10000012.000000000"  #Top turret/Right spindle, Right Face cut
scase_tr_c_2 : "10110012.000000000"  #Top turret/Right spindle, Left Face cut
scase_tr_c3  : "10010102.000000000"  #Top turret/Right spindle, Cross cut (cuttype = 3)
scase_tr_c3r : "10001102.000000000"  #Top turret/Right spindle, Reverse Cross cut (cuttype = -3)
scase_tr_c4c : "10000222.000000000"  #Top turret/Right spindle, Y axis subs. Cycle
scase_tr_c4  : "10000222.000000000"  #Top turret/Right spindle, Y axis subs.
scase_tr_c5  : "10000222.000000000"  #Top turret/Right spindle, Multisurf Rotary

#Columns-    ABCDEFGH.IJKLMNOPQ
scase_br_c1  : "10000222.000000000"  #Bottom turret/Right spindle, Turning cut
scase_br_c2  : "10000222.000000000"  #Bottom turret/Right spindle, Right Face cut
scase_br_c_2 : "10110222.000000000"  #Bottom turret/Right spindle, Left Face cut
scase_br_c3  : "10010222.000000000"  #Bottom turret/Right spindle, Cross cut (cuttype = 3)
scase_br_c3r : "10010222.000000000"  #Bottom turret/Right spindle, Reverse Cross cut (cuttype = -3)
scase_br_c4c : "10000222.000000000"  #Bottom turret/Right spindle, Y axis subs. Cycle
scase_br_c4  : "10000222.000000000"  #Bottom turret/Right spindle, Y axis subs.
scase_br_c5  : "10000222.000000000"  #Bottom turret/Right spindle, Multisurf Rotary

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
#Post Setup Variable Initializations (Generally these are not modified)
sub_level$   : 1        #CD_VAR Enable automatic subprogram support
breakarcs$   : 1        #CD_VAR Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
arctype$     : 2        #CD_VAR arctype$, arctpeyz$, arctypxz$
                                #Arc center 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.,
                                #5 = R no sign, 6 = R signed neg. over 180
do_full_arc$ : 0     #CD_VAR Allow full circle output? 0=no, 1=yes
helix_arc$   : 0        #CD_VAR Support helix arc output, 0=no, 1=all planes, 2=XY plane only
arccheck$    : 1        #CD_VAR Convert small arcs to linear
atol$        : 0.01         #CD_VAR Angularity tolerance for arccheck
ltol$        : 0.002        #CD_VAR Length tolerance for arccheck
vtol$        : 0.0001   #System tolerance
maxfeedpm    : 500#Limit for feed in inch/min
lcc_move     : 0.05  #Enter the move in X, Z for lathe canned cycle comp.
vtol_m       : 0.0025   #System tolerance, metric
maxfeedpm_m  : 10000 #Limit for feed in mm/min
lcc_move_m   : 1.25     #Enter the move in X, Z for lathe canned cycle comp.,mm
spaces$      : 1            #CD_VAR Number of spaces to add between fields
omitseq$     : yes$     #CD_VAR Omit sequence numbers? (use -1 to enable sequence for LCC)
seqmax$      : 9999     #CD_VAR Max. sequence number
nobrk$       : no$          #CD_VAR Omit breakup of x, y & z rapid moves
rotaxtyp$    : 3            #Rotary axis type for toolplane
tooltable$   : 3            #Read for tool table and pwrtt (3 recalls pwrtt at sof)

ref_ret     : 0                 #referance return variable from hard_mi3

cuttype     : 0                 #Flag for cut type
                                    #1 = Lathe
                                    #2 = Right face cut
                                    #-2 = Left face cut
                                    #3 = Cross cut
                                    #-3 = Reverse Cross cut                    
                                    #4 = Y axis substitution
                                    #5 = Multisurf Rotary 4 axis or 11 gcode

lathtype    : 0                 #Lathe turret and spindle selection
                                    #0 = Bottom turret/Left spindle
                                    #1 = Top turret/Left spindle
                                    #2 = Bottom turret/Right spindle
                                    #3 = Top turret/Right spindle

lathecc     : 0                 #Flag for canned turning cycle type
                                    #1 = G71/G72 rough cycle
                                    #2 = G73 pattern repeating cycle
                                    #3 = G74/G75 groove cycle
                                    #4 = Finish pass for types 1 and 2
                                    #Neg.=rough and finish, Pos.=rough only

millcc      : 0                 #Flag for mill conversion cycle type

comp_type   : 0             #Cutter compensation type 
                                    #0 = Computer
                                    #1 = Control 
                                    #2 = Wear
                                    #3 = Reverse wear 
                                    #4 = Off

metvals     : 0     #Use inch/metric values switch in tool parameters
                            #0 = inch values, 1 = metric values. Affects pitch in tapping

#Cantext activated flags
bld         : 0     #Block delete active
exact       : 0     #Exact stop active
chute       : 0     #Toggle for part catcher operation
tlstk       : 0     #Toggle for tailstock operation

# User Prompt Definition
fq 1 bar_out    "OUTPUT BAR FEED COMMAND 0=NO 1=YES"
fq 2 z_pos      "Enter Z Stop Position"

#General user variables
svn             : 0     # Saved N Number
mt_flg          : 0     # mill turn flag 
bar_out         : 0     # Bar Feeder Variable
wkof                : 0     # Work Offset From Parameter File
sof_flg         : 1      # Start Of File Flag
sof_flg2        : 1      # Start Of File Flag 2
bar_flg         : 0      # Bar Feed Flag From Misc Ops
sp_rpm          : 0      # Spindle RPM From Parameter File
c_del               : 0      # C Delta Variable
p_ang           : 0      #  Sub Spindle Rotary Position 
spdnl               : 0      # Spindle Number From Parameter Ffile
mr1$                : 0     # Initial G58 B Position
mr2$                : 0     # Feed Onto Bar Distance
mr3$                : 0     # Stock Advance Distance
mr4$                : 0     # Main Spindle Orientation Angle
mr_ttl              : 0     # Temporary Misc. Real Total
pick_flg        : 0    # Pick Off Flag

xia         : 0     #Formated absolute value for X
yia         : 0     #Formated absolute value for Y
zia         : 0     #Formated absolute value for Z
cia         : 0     #Formated absolute value for C
copy_x      : 0     #X value copy, prevent compound operations
copy_y      : 0     #Y value copy, prevent compound operations
copy_z      : 0     #Z value copy, prevent compound operations
xa          : 0     #Absolute coordinate mapped value for X
ya          : 0     #Absolute coordinate mapped value for Y
za          : 0     #Absolute coordinate mapped value for Z
cfeed_x     : 0     #Absolute mapped/rotated unshifted value for X
cfeed_y     : 0     #Absolute mapped/rotated unshifted value for Y
cfeed_z     : 0     #Absolute mapped/rotated unshifted value for Z
xca         : 0     #Absolute unshifted value for XC
yca         : 0     #Absolute unshifted value for YC
zca         : 0     #Absolute unshifted value for ZC
sav_xa      : 0     #X saved value
sav_ya      : 0     #Z saved value
sav_za      : 0     #Z saved value
sav_xh      : 0     #X saved value
sav_yh      : 0     #Z saved value
sav_zh      : 0     #Z saved value
start_xh    : 0
start_yh    : 0
start_zh    : 0
sav_cc_1013 : 1     #Capture value of cc_1013 flag  # 1/17/03
clamp_code  : -1    #String select variable
conversion  : 12    #Unit conversion value, do not change
result      : 0     #Return value for functions
compok      : 1     #Flag to output cutter compensation
toolchng    : 2     #On a toolchange flag
toolchng0   : 2     #On a null toolchange flag
plane$      :  -1   #Initialize plane
ipr_actv$   :  -1   #Initialize active feed type
mach_plane  : 0     #Plane mapped to machine
sav_arcout  : arcoutput$ #Arc output type saved
breakarcss  : 0     #saved breakarcs$ value
g71type     : 0     #lathe plunge for G71 type 1 or type 2 cycle
counter     : 0     #Counter
nstrlen     : 0     #Length of string
sav_absinc  : 0     #Saved absolute/Incremental
spd_rev     : 0     #Flag to reverse spindle direction
sav_gcode   : 0     #Gcode saved
sav_feed    : 0     #Feed saved
sav_ipr     : 0     #IPR saved
sav_feedcc  : 0     #Feed saved, canned cycle
sav_iprcc   : 0     #IPR saved, canned cycle
sav_spdir   : 0     #Spindle direction saved
sav_omitsq  : 0     #Omitseq saved
sav_subout  : 0     #Saved subout
sav_frc_wcs : 0     #Force work offset flag saved
sav_bug2    : bug2$  #Saved setting for bug2
sav_cutpos2 : 0     #Patch to handle cutpos2 flag through null toolchnages
sav_eob     : 0     #eob saved
cir_at_zero : 0     #Arc center at centerline in XY plane, -1 if not plane 0
pnt_at_zero : 0     #Position at centerline with milling
c_ax_flp    : 0     #G18 plane with C axis arcs in neg. range
rslt_plc    : 0     #Return value from plcval
rslt_upd    : 0     #Return value from updstr

#Drilling variables
drlgsel     :  -1   #Drill Select Initialize
drillref    :  -1   #Select drill reference
peckacel$   : 0     #Fractional percent to reduce peck2 when usecan.. : no
mdrl_dir    : 0     #Mill drill direction for boolean, 0 = face, 1 = cross
zdrl_x      : 0     #Drill point, mapped X
zdrl_y      : 0     #Drill point, mapped Y
zdrl_z      : 0     #Drill point, mapped Z

#Threading variables
nstart_cnt  : 0     #Counter for multiple threads
thd_vlen    : 0     #Incremental X move for G76 mult starts
xmaj_thd    : 0     #X major dia. from parameters
zstrt_thd   : 0     #Z start from parameters
zend_thd    : 0     #Z end from parameters
face_thd    : 0     #Face thread from parameters

#Spindle variables
max_speed   : 0     #Maximum spindle speed (set by turret definition)
min_speed   : 0     #Minimum spindle speed (set by turret definition)
speedrpm    : 0     #Spindle calculation RPM
g_speed     : 0     #Generic positive spindle speed (rpm or css)
g_spdir     : 999   #Generic spindle direction
speedx      : 0     #Test spindle calculation X position
gear_spd    : 0     #Absolute value of gear speed

# Lathe canned cycle variables
gcodecc     : 0     #Canned turning cycle gcode
y_axis      : 0     #Flag for Y axis machining (implies over center)
directcc    : 0     #Direction from parameters
dopeckcc    : 0     #Do peck from groove parameters
foundcc     : 0     #Return found from G70 read
cc_stop_fcc : 0     #Stop output with rough only
lcc_cc_pos  : 0     #Position for lathe canned cycle cutter comp. enable
lccdirx     : 0     #Canned cycle X vector direction
lccdirz     : 0     #Canned cycle Z vector direction
lcc_xcst    : 0     #Lathe canned cycle contour start position
lcc_ycst    : 0     #Lathe canned cycle contour start position
lcc_zcst    : 0     #Lathe canned cycle contour start position
lcc_xcend   : 0     #Lathe canned cycle contour end position
lcc_ycend   : 0     #Lathe canned cycle contour end position
lcc_zcend   : 0     #Lathe canned cycle contour end position

#_last variables to keep track of previous values (see plast)
last_millcc  : 0     #Previous value of millcc
last_op_id   : 0     #Previous value of op_id$
last_cuttype : 0     #Previous value of cuttype
last_spindle_no : 0  #Previous value of spindle_no$

#_flg variables
interp_flg   : 0     #Interpolation output currently on
clamp_flg    : 0     #Clamp curently on or off
synch_flg    : 0     #Flag for synched spindle work
force_flg  : 0       #Flag to indicate forced output in mtlchg0,ltlchg0

#Vector Variables for Mapping and Rotary Calculations
#Lathe - Uses top matrix - initialize here
m1$          : 1
m5$          : 1
m9$          : 1

#C rotation vector
caxisx      : 0
caxisy      : 0
caxisz      : 1

#Mapping matrix
#Home position mapping matrix
hmtx1       : 1
hmtx2       : 0
hmtx3       : 0
hmtx4       : 0
hmtx5       : 1
hmtx6       : 0
hmtx7       : 0
hmtx8       : 0
hmtx9       : 1

#Cut type mapping matrix
mmtx1       : 1
mmtx2       : 0
mmtx3       : 0
mmtx4       : 0
mmtx5       : 1
mmtx6       : 0
mmtx7       : 0
mmtx8       : 0
mmtx9       : 1

#Side matrix
smtx1       : 0
smtx2       : 1
smtx3       : 0
smtx4       : 0
smtx5       : 0
smtx6       : 1
smtx7       : 1
smtx8       : 0
smtx9       : 0

#Cross matrix
cmtx1       :  -1
cmtx2       : 0
cmtx3       : 0
cmtx4       : 0
cmtx5       : 0
cmtx6       : 1
cmtx7       : 0
cmtx8       : 1
cmtx9       : 0

#Reversed cross matrix
crmtx1      : 1
crmtx2      : 0
crmtx3      : 0
crmtx4      : 0
crmtx5      : 0
crmtx6      : -1
crmtx7      : 0
crmtx8      : 1
crmtx9      : 0

#Back matrix
bmtx1       : 0
bmtx2       :  -1
bmtx3       : 0
bmtx4       : 0
bmtx5       : 0
bmtx6       : 1
bmtx7       :  -1
bmtx8       : 0
bmtx9       : 0

#Axis Subs matrix
amtx1       : 1
amtx2       : 0
amtx3       : 0
amtx4       : 0
amtx5       : 0
amtx6       : 1
amtx7       : 0
amtx8       : 1
amtx9       : 0

#C-axis variables for calculations
one_rev     : 1     #0 = Absolute positioning with wind up, 1 = 0 to 360 closest direction
c_axistype  : 0     #1 = C axis winds-up, 2 = C axis signed absolute
                    #3 = index positioning (do not set here, use string)
ipr_type    : 0     #Feedrate for Rotary, 0 = UPM, 1 = DPM
csav        : 0     #Initial c axis result from pxyzcout call
last_csav   : 0     #Initial c axis result from pxyzcout call
czero_csav  : 0     #Save csav when circle at zero detected
c_wnd       : 0     #Calculation for c axis position tracking (abs-wind)
prvc_wnd    : 0     #Saved cout calculation from deg., this is cabs in mpfan
rev         : 0     #C axis wind-up multiplier
prvfrdeg    : 0     #Feedrate deg/min actual
circum      : 0     #Circumference
ldelta      : 0     #Linear distance for deg/min, linear
cdelta      : 0     #Total linear and angular motion for deg/min
cldelta     : 0     #Calculation for deg/min, linear and rotary
sav_rev     : 0     #Saved revolution counter
indx_out    : c9k   #Rotation direction calculation
fmt     17  frdeg   #Feedrate deg/min actual
fmt     20  indx_mc #Rotation direction calculation

#Coolant variables for X style coolant
cant_pos     : 0    #Read from current canned text (cant_pos1 - cant_pos20)
coolant_bin  : 0    #Binary value for current coolant command
coolant_on   : 0    #Binary value holding the sum of all coolants currently on
coolantx     : 0    #Selector variable for coolant string selector
local_int    : 0    #Local variable for output of coolant off commands
result2      : 0    #Return value for functions
suppress     : 0    #Flag used to suppress redundant coolant on commands
all_cool_off : 0    #SET_BY_MD - First coolant off command shuts off ALL coolant options
v9_coolant   : 0    #SET_BY_MD - Use V9 coolant options - read from General Machine Parameters

#SET BY MD - Variables to capture parameter values - use to set post switches in pset_mach
rot_axis     : 0     #Axis of rotation - 1=X, 2=Y, 3=Z
rot_type     : 0     #Rotary type - 0=signed continuous, 1=signed absolute, 2=shortest direction
rot_dir      : 0     #Rotary direction - CW is positive, 0 = false, 1 = true
rot_index    : 0     #Index or continuous - 0 = continuous, 1 = index
rot_angle    : 0     #Degrees for each index step with indexing spindle
component_type : 0   #Component type: (See documentation for complete list - )
                       #0 = MACHINE
                       #1 = STOCK_COMPONENT
                       #2 = MISC_COMPONENT
                       #3 = MACHINE_BASE_COMPONENT
                       #4 = LINEAR_AXIS_COMPONENT
                       #5 = ROTARY_AXIS_COMPONENT
                       #6 = RECT_TABLE_COMPONENT
                       #12 = CHUCK_COMPONENT
                       #24 = TOOL_SPINDLE_COMPONENT
                       #23 = ATC_COMPONENT
xpos_dir        : 0    #x Axis direction flag
ypos_dir        : 0    #y Axis direction flag
zpos_dir        : 0    #Z Axis direction flag
axis_label   : 0     #Axis label - 1=X,2=Y,3=Z
write_ops    : 0     #Write NC operation information (True/False)


#Plane/axis sign modifier (always 1 or -1)
pl_ax_m0x   : 1
pl_ax_m0y   : 1
pl_ax_m0z   : 1
pl_ax_m1x   : 1
pl_ax_m1y   : 1
pl_ax_m1z   : 1
pl_ax_m2x   : 1
pl_ax_m2y   : 1
pl_ax_m2z   : 1

# --------------------------------------------------------------------------
# Buffer definitions
# --------------------------------------------------------------------------
#Buffer 1, toolchange information
wc1           : 1       #Initial count for write buffer 1
rc1           : 1       #Initial count for read buffer 1
nc1           : 2       #Initial count for read buffer 1 into next record
size1         : 0       #Buffer 1 size

# Current tool information
c1_gcode      : 0       #Buffer 1
c1_xh         : 0       #Buffer 1
c1_yh         : 0       #Buffer 1
c1_zh         : 0       #Buffer 1
c1_tox        : 0       #Buffer 1
c1_toy        : 0       #Buffer 1
c1_toz        : 0       #Buffer 1
c1_cc_pos     : 0       #Buffer 1
c1_tool       : 0       #Buffer 1
c1_tloffno    : 0       #Buffer 1
c1_maxss      : 0       #Buffer 1
c1_ss         : 0       #Buffer 1
c1_spdir      : 0       #Buffer 1
c1_css_actv   : 0       #Buffer 1
c1_fr_pos     : 0       #Buffer 1
c1_ipr_actv   : 0       #Buffer 1
c1_coolant    : 0       #Buffer 1
c1_nextdc     : 0       #Buffer 1
c1_posttype   : 0       #Buffer 1
c1_cuttype    : 0       #Buffer 1
c1_lathtype   : 0       #Buffer 1
c1_gcodecc    : 0       #Buffer 1
c1_lathecc    : 0       #Buffer 1
c1_millcc     : 0       #Buffer 1
c1_y_axis     : 0       #Buffer 1
c1_x_min      : 0       #Buffer 1
c1_x_max      : 0       #Buffer 1
c1_spindle_no : 0       #Buffer 1
c1_mr1              : 0     #Buffer 1   #5/29/08
c1_mr2              : 0     #Buffer 1   #5/29/08
c1_mr3              : 0     #Buffer 1   #5/29/08
c1_mr4              : 0     #Buffer 1   #5/29/08

# Next tool information
n1_gcode      : 0       #Buffer 1
n1_xh         : 0       #Buffer 1
n1_yh         : 0       #Buffer 1
n1_zh         : 0       #Buffer 1
n1_tox        : 0       #Buffer 1
n1_toy        : 0       #Buffer 1
n1_toz        : 0       #Buffer 1
n1_cc_pos     : 0       #Buffer 1
n1_tool       : 0       #Buffer 1
n1_tloffno    : 0       #Buffer 1
n1_maxss      : 0       #Buffer 1
n1_ss         : 0       #Buffer 1
n1_spdir      : 0       #Buffer 1
n1_css_actv   : 0       #Buffer 1
n1_fr_pos     : 0       #Buffer 1
n1_ipr_actv   : 0       #Buffer 1
n1_coolant    : 0       #Buffer 1
n1_nextdc     : 0       #Buffer 1
n1_posttype   : 0       #Buffer 1
n1_cuttype    : 0       #Buffer 1
n1_lathtype   : 0       #Buffer 1
n1_gcodecc    : 0       #Buffer 1
n1_lathecc    : 0       #Buffer 1
n1_millcc     : 0       #Buffer 1
n1_y_axis     : 0       #Buffer 1
n1_x_min      : 0       #Buffer 1
n1_x_max      : 0       #Buffer 1
n1_spindle_no : 0       #Buffer 1 
n1_mr1              : 0     #Buffer 1   #5/29/08
n1_mr2              : 0     #Buffer 1   #5/29/08
n1_mr3              : 0     #Buffer 1   #5/29/08
n1_mr4              : 0     #Buffer 1   #5/29/08

fbuf 1 0 32 0 0         #Buffer 1   #5/29/08
# --------------------------------------------------------------------------
#Buffer 2, recall lathe canned turning cycle line numbers
wc2           : 1       #Initial count for write buffer 2
rc2           : 1       #Initial count for read buffer 2
size2         : 0       #Buffer 2 size

fcc_subid     : 0       #Buffer 2
fcc_ng70s     : 0       #Buffer 2
fcc_ng70e     : 0       #Buffer 2

fbuf 2 0 3 0 0          #Buffer 2
# --------------------------------------------------------------------------
#Buffer 3, output strings for lathe canned turning cycles
wc3           : 1       #Initial count for write buffer 3
rc3           : 1       #Initial count for read buffer 3
size3         : 0       #Buffer 3 size

string3 : ""                 #Buffer 3

fbuf 3 0 80 1 1         #Buffer 3
# --------------------------------------------------------------------------
#Buffer 4, used to sav X and Z initial values for lathe canned rough and finish #CRF
wc4             : 1       #Initial count for write buffer 4
rc4             : 1       #Initial count for read buffer 4
size4           : 0       #Buffer 4 size

crf_line        : 0     #Canned cycle line number
crf_xsav1       : 0     #Saved X value before lathe canned rough for use with lathe canned finish
crf_zsav1       : 0     #Saved Z value before lathe canned rough for use with lathe canned finish
crf_xsav2       : 0     #Saved X value before lathe canned rough for use with lathe canned finish
crf_zsav2       : 0     #Saved Z value before lathe canned rough for use with lathe canned finish

fbuf 4 0 2 0 0         #Buffer 4
# --------------------------------------------------------------------------
#User String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Address string definitions
stra        : "A"     #String for address A
strc        : "C"     #String for address C
strd        : "D"     #String for address D
stre        : "E"     #String for address E
strf        : "F"     #String for address F
strh        : "H"     #String for address H
stri        : "I"     #String for address I
strk        : "K"     #String for address K
strm        : "M"     #String for address M
stro        : "O"     #String for address O
strp        : "P"     #String for address P
strq        : "Q"     #String for address Q
stru        : "U"     #String for address U
strw        : "W"     #String for address W
strr        : "R"     #String for address R (radius)
srminus     : "R-"    #String for address R- (minus radius)
strs        : "S"     #String for address S
stry        : "Y"     #String for address Y
sc_minus    : "-"     #Manipulated string for signed rotary minus

sunclmp_main : "M10 (UNCLAMP MAIN)"    #String Definition
sclmp_main   : "M11 (CLAMP MAIN)"         #String Definition
sunclmp_sub  : "M111 (UNCLAMP SUB)"   #String Definition
sclmp_sub    : "M110 (CLAMP SUB)"         #String Definition

sp_selmn        : "M190"      # Main Spindle Select
sp_selsb        : " M191"     # Sub spindle select

#Tool note
stinsert    : "INSERT - " #String for tool notes
stinsert2 : ""               #String for tool notes
stholder    : "HOLDER - " #String for tool notes
stholder2 : ""               #String for tool notes
snocomm     : "DEFINE TOOL NAMES"

#Misc Strings
scomm_str   : "("
scomm_end   : ")"
snull       : ""      # Null character string

#String definitions
sg50        : "G92"   #String for spindle clamp and work coordinate

#Cantext string definitions (spaces must be padded here)
sm00        : "M00"       #String for stop
sm01        : "M01"       #String for optional stop
strtextno : ""                   #String for cantext
strcantext : ""                  #String for cantext

sblank : ""                      #Empty string
sw_string : ""                   #String for lathe turret type settings
# --------------------------------------------------------------------------
# Error message strings
# --------------------------------------------------------------------------
saxiserror  : "ERROR-WRONG AXIS OF ROTATION, ROTATE ON X AXIS OF WCS"
sindxerror  : "WARNING-INDEX ANGLE DOES NOT MATCH MACHINE DEF SETTING ('INDEX ANGLE')"
ssignerror  : "WARNING-SIGNED AXIS POSITIONING MOVE OVER 360 DEGREES"
swrkserror  : "WARNING-WORK OFFSET IS CHANGED IN A SUBPROGRAM"
stoperror   : "ERROR-AXIS SUBSTITUTION MUST USE THE TOP TOOLPLANE"
scutterror  : "ERROR-A VALID CUT TYPE WAS NOT FOUND, CHECK ROTARY SETTINGS"
sfccerror   : "ERROR-MATCHING G70 FINISH PROFILE WAS NOT FOUND"
s5drlerror  : "ERROR-5 AXIS DRILLING REQUIRES LONG CYCLE ('usecan..')"
slthrmerror : "ERROR-ROTATE/MIRROR SUBPROGRAM NOT ALLOWED WITH LATHE PATH"
smilrmerror : "ERROR-ROTATE/MIRROR PROGRAM ROUTINE NOT ALLOWED"
smny50error : "ERROR-G50 AND HOME ('mi1') DOES NOT SUPPORT MULTIPLE TOOL SUBPROGRAM"
shomeserror : "ERROR-HOME ('mi1') DOES NOT SUPPORT TRANSFORM SUBPROGRAM"
symoterror  : "WARNING-Y AXIS MOTION ENCOUNTERED.  NO Y AXIS DEFINED IN MACHINE - CHECK AXIS COMBINATION"
swriteopserror : "ERROR - WRITE NC OPERATION INFORMATION MUST BE ENABLED IN CONTROL DEFINITION - SET AND REPOST"

# --------------------------------------------------------------------------
# General G and M Code String select tables
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg02   : "G2"       #Circular interpolation CW
sxg03   : "G3"       #Circular interpolation CCW
# --------------------------------------------------------------------------
# Motion G code selection
sg00    : "G0"       #Rapid
sg01    : "G1"       #Linear feed
sg02    : "G2"       #Circular interpolation CW
sg03    : "G3"       #Circular interpolation CCW
sg04    : "G4"       #Dwell
sgcode : ""          #Target for string

fstrsel sg00 gcode$ sgcode 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 1
sg00_1  : "G0"       #Rapid
sg01_1  : "G1"       #Linear feed
sg02_1  : "G2"       #Circular interpolation CW
sg03_1  : "G3"       #Circular interpolation CCW
sg04_1  : "G4"       #Dwell
sgcode1 : ""         #Target for string

fstrsel sg00_1 gcode$ sgcode1 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 2
sg00_2  : "G0"       #Rapid
sg01_2  : "G1"       #Linear feed
sg02_2  : "G2"       #Circular interpolation CW
sg03_2  : "G3"       #Circular interpolation CCW
sg04_2  : "G4"       #Dwell
sgcode2 : ""         #Target for string

fstrsel sg00_2 gcode$ sgcode2 5 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg17   : "G17"      #XY plane code
sxg19   : "G19"      #YZ plane code
sxg18   : "G18"      #XZ plane code
swstr : ""              #Target for string

fstrsel sxg17 rslt_plc swstr 3 -1
# --------------------------------------------------------------------------
# Select work plane G code
sg17    : "G17"      #XY plane code
sg19    : "G19"      #YZ plane code
sg18    : "G18"      #XZ plane code
sgplane : ""            #Target string

fstrsel sg17 plane$ sgplane 3 -1
# --------------------------------------------------------------------------
#Select english/metric code
sg20    : "G20"      #Inch code
sg21    : "G21"      #Metric code
smetric : ""         #Target string

fstrsel sg20 met_tool$ smetric 2 -1
# --------------------------------------------------------------------------
#Select reference return code
sg28    : "G28"      #First reference point return
sg30    : "G30"      #Second reference point return
sg53    : "G53"   #Third reference point return
sg28ref : ""         #Target string

fstrsel sg28 ref_ret sg28ref 3 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg41   : "G41"      #Cutter compensation left
sxg42   : "G42"      #Cutter compensation right
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 0
sg40    : "G40"      #Cancel cutter compensation
sg41    : "G41"      #Cutter compensation left
sg42    : "G42"      #Cutter compensation right
sccomp : ""          #Target for string

fstrsel sg40 cc_pos$ sccomp 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 1
sg40_1  : "G40"      #Cancel cutter compensation
sg41_1  : "G41"      #Cutter compensation left
sg42_1  : "G42"      #Cutter compensation right
sccomp1 : ""         #Target for string

fstrsel sg40_1 cc_pos$ sccomp1 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 2
sg40_2  : "G40"      #Cancel cutter compensation
sg41_2  : "G41"      #Cutter compensation left
sg42_2  : "G42"      #Cutter compensation right
sccomp2 : ""         #Target for string

fstrsel sg40_2 cc_pos$ sccomp2 3 -1
# --------------------------------------------------------------------------
# Select canned cycle type, profile is direction of finish profile vector
sthdg32 : "G32"      #Cycle type G32
sthdg76 : "G76"      #Cycle type G76
sthdg92 : "G92"      #Cycle type G92
sthdg33 : "G32"      #Cycle type G32 with alternating position
sthdgcode : ""       #Target for string

fstrsel sthdg32 thdtype$ sthdgcode 4 -1
# --------------------------------------------------------------------------
# Select canned cycle type
sg70    : "G70"      #Cycle type G70
sg71    : "G71"      #Cycle type G71
sg72    : "G72"      #Cycle type G72
sg73    : "G73"      #Cycle type G73
sg74    : "G74"      #Cycle type G74
sg75    : "G75"      #Cycle type G75
scclgcode : ""       #Target for string

fstrsel sg70 gcodecc scclgcode 6 -1
# --------------------------------------------------------------------------
# Canned drill cycle string select
sg80_f  : "G83"      #drill face
sg80_fd : "G83"      #drill face w/dwell
sg81_f  : "G83"      #peck face
sg81_fd : "G83"      #peck face w/dwell
sg82_f  : "G83"      #chpbrk face
sg82_fd : "G83"      #chpbrk face w/dwell
sg83_f  : "G84"      #tap right face
sg83_fd : "G84"      #tap left face
sg84_f  : "G85"      #bore1 face
sg84_fd : "G85"      #bore1 face w/dwell
sg85_f  : "G86"      #bore2 face
sg85_fd : "G88"      #bore2 face w/dwell
sg86_f  : "G87"      #misc1 face
sg86_fd : "G87"      #misc1 face w/dwell
sg87_f  : "G8?"      #misc2 face
sg87_fd : "G8?"      #misc2 face w/dwell
sgdrillf : ""        #Target for string

fstrsel sg80_f drlgsel sgdrillf 16 -1
# --------------------------------------------------------------------------
sg80_c  : "G87"      #drill cross
sg80_cd : "G87"      #drill cross w/dwell
sg81_c  : "G87"      #peck cross
sg81_cd : "G87"      #peck cross w/dwell
sg82_c  : "G87"      #chpbrk cross
sg82_cd : "G87"      #chpbrk cross w/dwell
sg83_c  : "G88"      #tap right cross
sg83_cd : "G88"      #tap left cross
sg84_c  : "G89"      #bore1 cross
sg84_cd : "G89"      #bore1 cross w/dwell
sg85_c  : "G86"      #bore2 cross
sg85_cd : "G88"      #bore2 cross w/dwell
sg86_c  : "G87"      #misc1 cross
sg86_cd : "G87"      #misc1 cross w/dwell
sg87_c  : "G8?"      #misc2 cross
sg87_cd : "G8?"      #misc2 cross w/dwell
sgdrillc : ""        #Target for string

fstrsel sg80_c drlgsel sgdrillc 16 -1
# --------------------------------------------------------------------------
#Tapping Strings
sm29    : "M29"      #Rigid Tapping
# --------------------------------------------------------------------------
# Select incremental or absolute G code
sg90 : ""    #G90     #Absolute code
sg91 : ""    #G91     #Incremental code
sgabsinc : ""        #Target string

fstrsel sg90 absinc$ sgabsinc 2 -1
# --------------------------------------------------------------------------
# RPM/CSS code selection
sg97    : "G97"      #RPM
sg96    : "G96"      #CSS
sg9697 : ""          #Target for string

fstrsel sg97 css_actv$ sg9697 2 -1
# --------------------------------------------------------------------------
# Feed mode G code selection
sg98    : "G94"      #UPM
sg99    : "G95"      #UPR
sgfeed : ""            #Target for string

fstrsel sg98 ipr_actv$ sgfeed 2 -1
# --------------------------------------------------------------------------
# C axis cycles
sg107   : "G07.1"     #C axis cylindrical interpolation enable
sg108   : "G07.1"     #C axis cylindrical interpolation disable
sg112   : "G12.1"     #C axis face polar interpolation enable
sg113   : "G13.1"     #C axis face polar interpolation disable
# --------------------------------------------------------------------------
#Canned drill cycle reference height
sg198 : ""   #G198   #Reference at initht
sg199 : ""   #G199   #Reference at refht
sgdrlref : ""        #Target for string

fstrsel sg198 drillref sgdrlref 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe main
sm04    : "M04"      # Spindle reverse - no coolant
sm05    : "M05"      # Spindle off     - no coolant
sm03    : "M03"      # Spindle forward - no coolant
sm14    : "M04"      # Spindle reverse - coolant
sm05c   : "M05"      # Spindle off     - coolant
sm13    : "M03"      # Spindle forward - coolant
spindle_l : ""       #Target for string

fstrsel sm04 g_spdir spindle_l 6 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe sub
sm04a    : "M04"      # Spindle reverse - no coolant
sm05a    : "M05"      # Spindle off     - no coolant
sm03a    : "M03"      # Spindle forward - no coolant
sm14a    : "M04"      # Spindle reverse - coolant
sm05ca   : "M05"      # Spindle off     - coolant
sm13a    : "M03"      # Spindle forward - coolant
spindle_ls : ""       #Target for string

fstrsel sm04a g_spdir spindle_ls 6 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe main and sub synch
sm04b    : "M04"      # Spindle reverse - no coolant
sm05b    : "M05"      # Spindle off     - no coolant
sm03b    : "M03"      # Spindle forward - no coolant
sm14b    : "M04"      # Spindle reverse - coolant
sm05cb   : "M05"      # Spindle off     - coolant
sm13b    : "M03"      # Spindle forward - coolant
spindle_l_synch : ""       #Target for string

fstrsel sm04b g_spdir spindle_l_synch 6 -1
# --------------------------------------------------------------------------
# Coolant M code selection for V9 style coolant
# Note: To enable V9 style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, enable first check box
#   Output of V9 style coolant commands in this post is controlled by scoolant
sm09    : "M9"       #Coolant Off
sm08    : "M8"       #Coolant Flood 
sm08_1  : "M8"       #Coolant Mist
sm08_2  : "M8"       #Coolant Tool
scoolant : ""        #Target for string

fstrsel sm09 coolant$ scoolant 4 -1
# --------------------------------------------------------------------------
# Coolant output code selection for X style coolant
# Note: To enable X style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, disable first check box
#   Output of X style coolant commands in this post is controlled by pcan, pcan1, & pcan2
scool50    : "M8"                 #Coolant 1 on value
scool51    : "M9"                 #Coolant 1 off value
scool52    : "M7"                 #Coolant 2 on value
scool53    : "M9"                 #Coolant 2 off value
scool54    : "M88"                #Coolant 3 on value
scool55    : "M89"                #Coolant 3 off value
scool56    : "M8(Coolant4=ON)"    #Coolant 4 on value
scool57    : "M9(Coolant4=OFF)"   #Coolant 4 off value
scool58    : "M8(Coolant5=ON)"    #Coolant 5 on value
scool59    : "M9(Coolant5=OFF)"   #Coolant 5 off value
scool60    : "M8(Coolant6=ON)"    #Coolant 6 on value
scool61    : "M9(Coolant6=OFF)"   #Coolant 6 off value
scool62    : "M8(Coolant7=ON)"    #Coolant 7 on value
scool63    : "M9(Coolant7=OFF)"   #Coolant 7 off value
scool64    : "M8(Coolant8=ON)"    #Coolant 8 on value
scool65    : "M9(Coolant8=OFF)"   #Coolant 8 off value
scool66    : "M8(Coolant9=ON)"    #Coolant 9 on value
scool67    : "M9(Coolant9=OFF)"   #Coolant 9 off value
scool68    : "M8(Coolant10=ON)"   #Coolant 10 on value
scool69    : "M9(Coolant10=OFF)"  #Coolant 10 off value
scoolantx : ""                    #Target for string

fstrsel scool50 coolantx scoolantx 20 -1

#X coolant has the option - First coolant off command shuts off ALL coolant options
sall_cool_off  : "M09" #Coolant off command output with all_cool_off

# --------------------------------------------------------------------------
# Table rotation direction, index
sindx_cw   : "M19"    #Rotate CW code
sindx_ccw  : "M19"    #Rotate CCW code
sindx_mc : ""        #Target for string

fstrsel sindx_cw indx_mc sindx_mc 2 -1
# --------------------------------------------------------------------------
# C axis mode
sm23 : ""    #M23     #Main C axis enable
sm24 : ""    #M24     #C axis disable
sm223 : ""   #M223    #Sub C axis enable
sm224 : ""   #M224    #Sub C axis disable
# --------------------------------------------------------------------------
# Tailstock M code selection
sm26    : "M26"      #Tailstock retracted
sm25    : "M25"      #Tailstock engaged
stlstk : ""          #Target for string

fstrsel sm26 tlstk stlstk 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, mill
sm52    : "M54 (LIVE TOOL ON)"      # Spindle reverse - no coolant
sm55    : "M55 (LIVE TOOL OFF)"      # Spindle off     - no coolant
sm51    : "M53 (LIVE TOOL ON)"      # Spindle forward - no coolant
sm54    : "M54 (LIVE TOOL ON)"      # Spindle reverse - coolant
sm55c   : "M55 (LIVE TOOL OFF)"      # Spindle off     - coolant
sm53    : "M53 (LIVE TOOL ON)"      # Spindle forward - coolant
spindle_m : ""       #Target for string

fstrsel sm52 g_spdir spindle_m 6 -1
# --------------------------------------------------------------------------
# Chute M code selection
sm73    : "M73"      #Chute retracted
sm74    : "M74"      #Chute engaged
schute : ""          #Target for string

fstrsel sm73 chute schute 2 -1
# --------------------------------------------------------------------------
#Spindle Clamping M-Codes   Main
sm89   : "M50"      #Clamp On
sm88   : "M88"      #Brake/Mid-Clamp On
sm90   : "M51"      #Clamp Off
smspdl_clmp : ""    #Target String

fstrsel sm89 clamp_code smspdl_clmp 3 -1
# --------------------------------------------------------------------------
#Spindle Clamping M-Codes   Sub
sm189   : "M189"      #Clamp On
sm188   : "M188"      #Brake/Mid-Clamp On
sm190   : "M190"      #Clamp Off
smspdl_clmps : ""    #Target String

fstrsel sm189 clamp_code smspdl_clmps 3 -1
# --------------------------------------------------------------------------
#Spindle Clamping M-Codes   main and sub synch
sm89a   : "M89 M189"     #Clamp On
sm88a   : "M88 M188"     #Brake/Mid-Clamp On
sm90a   : "M90 M190"     #Clamp Off
smspdl_clmp_synch : ""    #Target String

fstrsel sm89a clamp_code smspdl_clmp_synch 3 -1
# --------------------------------------------------------------------------
# Cutter Compensation Type
scomp   : "COMPUTER"
scomp1  : "CONTROL COMP"
scomp2  : "WEAR COMP"
scomp3  : "REVERSE WEAR COMP"
scomp4  : "OFF"
scomp_type : ""

fstrsel scomp comp_type scomp_type 5 -1
# --------------------------------------------------------------------------
# Month selector
smon0   : ""
smon1   : "JAN."
smon2   : "FEB."
smon3   : "MAR."
smon4   : "APR."
smon5   : "MAY."
smon6   : "JUN."
smon7   : "JUL."
smon8   : "AUG."
smon9   : "SEP."
smon10  : "OCT."
smon11  : "NOV."
smon12  : "DEC."
smonth : ""

fstrsel smon0 month$ smonth 13 -1

# --------------------------------------------------------------------------
# Define the gear selection code
flktbl  1       3       #Lookup table definition - table no. - no. entries
        40      0       #Low gear range
        41      400     #Med gear range
        42      2250    #Hi gear range

# --------------------------------------------------------------------------
# Define coolant binary value for X style coolant
flktbl  2       20      #Lookup table definition - table no. - no. entries
        1       50      #Coolant 1 on value
        2       51      #Coolant 1 off value
        4       52      #Coolant 2 on value
        8       53      #Coolant 2 off value
        16      54      #Coolant 3 on value
        32      55      #Coolant 3 off value
        64      56      #Coolant 4 on value
        128     57      #Coolant 4 off value
        256     58      #Coolant 5 on value
        512     59      #Coolant 5 off value
        1024    60      #Coolant 6 on value
        2048    61      #Coolant 6 off value
        4096    62      #Coolant 7 on value
        8192    63      #Coolant 7 off value
        16384   64      #Coolant 8 on value
        32768   65      #Coolant 8 off value
        65536   66      #Coolant 9 on value
        131072  67      #Coolant 9 off value
        262144  68      #Coolant 10 on value
        524288  69      #Coolant 10 off value

# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
#Default english/metric position format statements
fs2 1   0.7 0.6     #Decimal, absolute, 7 place, default for initialize (:)
fs2 2   0.4 0.3     #Decimal, absolute, 4/3 place
fs2 3   0.4 0.3d    #Decimal, delta, 4/3 place
#Common format statements
fs2 4   1 0 1 0     #Integer, not leading
fs2 5   2 0 2 0l    #Integer, force two leading
fs2 6   3 0 3 0l    #Integer, force three leading
fs2 7   4 0 4 0l    #Integer, force four leading
fs2 9   0.1 0.1     #Decimal, absolute, 1 place
fs2 10  0.2 0.2     #Decimal, absolute, 2 place
fs2 11  0.3 0.3     #Decimal, absolute, 3 place
fs2 12  0.4 0.4     #Decimal, absolute, 4 place
fs2 13  0.5 0.5     #Decimal, absolute, 5 place
fs2 14  0.3 0.3d    #Decimal, delta, 3 place
fs2 15  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 16  0 4 0 3t    #No decimal, absolute, 4 trailing
#Default english/metric feed format statements
fs2 17  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 18  0.4 0.3     #Decimal, absolute, 4/3 place
fs2 19  0.5 0.4     #Decimal, absolute, 5/4 place
fs2 20  1 0 1 0n    #Integer, forced output
fs2 25  1.4 1.3lt   #Decimal, absolute, 4/3 trailing

# These formats used for 'Date' & 'Time'
fs2 21  2.2 2.2lt    #Decimal, force two leading & two trailing (time2)
fs2 22  2 0 2 0t     #Integer, force trailing                   (hour)
fs2 23  0 2 0 2lt    #Integer, force leading & trailing         (min)

# This format statement is used for sequence number output
# Number of places output is determined by value for "Increment Sequence Number" in CD
# Max depth to the right of the decimal point is set in the fs statement below
fs2 24  0^7 0^7      #Decimal, 7 place, omit decimal if integer value

# --------------------------------------------------------------------------
# Toolchange / NC output Variable Formats
# --------------------------------------------------------------------------
fmt  "P" 24 svn             # Saved N Number Format
fmt  "T" 7  toolno          #Tool number
fmt  "G" 4  g_wcs           #WCS G address
fmt  "P" 4  p_wcs           #WCS P address
fmt  "S" 4  speed           #Spindle Speed
fmt  "M" 4  gear            #Gear range
fmt  "S" 4  maxss$       #RPM spindle speed
# --------------------------------------------------------------------------
fmt  "Z" 2   z_pos      # Bar Stop Z Value From Prompt
fmt  "X" 2  utxref       # Upper Turret X Position
fmt  "Z" 2  utzref       # Upper Turret Z Position
fmt       2   chute       # Used For modality
fmt  "X" 2  mx           # Move X slide
fmt  "Y" 2  my           # Move Y slide
fmt  "Z" 2  mz           # Move Z slide
fmt  "B" 2  mr1$        # Initial B Position            #5/29/08
fmt  "B" 2  mr2$        # Feed Onto Bar         #5/29/08
fmt  "B" 2  mr3$        # Stock Advance         #5/29/08
fmt  "S" 11 mr4$        # Sub C axis position   #5/29/08
fmt  "P" 11 p_ang       # P Sub Spindle Rotary Position  #5/29/08
fmt       11  c_del       # C Delta Value                           #5/29/08
fmt  "N" 24  n$           # Sequence number
fmt  "X" 2  xabs        # X position output
fmt  "Y" 2  yabs        # Y position output
fmt  "Z" 2  zabs        #Z position output
fmt  "U" 3  xinc        #X position output
fmt  "V" 3  yinc        #Y position output
fmt  "W" 3  zinc        #Z position output
fmt  "C" 11 cabs        #C axis position
fmt  "H" 14 cinc        #C axis position
fmt  "C" 11 cout_a      #C axis position
fmt  "H" 14 cout_i      #C axis position
fmt  "C" 11  indx_out    #Index position
fmt  "I" 3  iout        #Arc center description in X
fmt  "J" 3  jout        #Arc center description in Y
fmt  "K" 3  kout        #Arc center description in Z
fmt  "R" 2  arcrad$      #Arc Radius
fmt  "F" 18 feed        #Feedrate
fmt  "P" 16 dwell$       #Dwell
fmt  "M" 5  cantext$     #Default cantext
fmt  "C" 2  crad        #C axis start radius, G107
# --------------------------------------------------------------------------
#Move comment (pound) to output colon with program numbers
fmt  "O" 7  progno$      #Program number
#fmt ":" 7   progno$      #Program number
fmt  "O" 7  main_prg_no$ #Program number
#fmt ":" 7   main_prg_no$ #Program number
fmt  "O" 7  sub_prg_no$  #Program number
#fmt ":" 7   sub_prg_no$  #Program number
fmt  "U" 2  sub_trnsx$   #Rotation point
fmt  "V" 2  sub_trnsy$   #Rotation point
fmt  "W" 2  sub_trnsz$   #Rotation point
# --------------------------------------------------------------------------
# Drill output
# --------------------------------------------------------------------------
fmt  "R" 2  refht_a         #Reference height
fmt  "R" 2  refht_i         #Reference height
fmt  "X" 2  initht_x    #Initial height, mapped X
fmt     2   initht_y    #Initial height, mapped Y
fmt  "Z" 2  initht_z    #Initial height, mapped Z
fmt  "X" 2  refht_x     #Reference height, mapped X
fmt     2   refht_y     #Reference height, mapped Y
fmt  "Z" 2  refht_z     #Reference height, mapped Z
fmt  "X" 2  depth_x     #Depth, mapped X
fmt     2   depth_y     #Depth, mapped Y
fmt  "Z" 2  depth_z     #Depth, mapped Z
fmt  "Q" 2 peck1$     #First peck increment (positive)
fmt     2   peck2$      #Second or last peck (positive)
fmt  "R" 2  peckclr$    #Safety distance
fmt     2   retr$       #Retract height
fmt  "Q" 16 shftdrl$    #Fine bore tool shift
fmt  "F" 2  pitch       #Tap pitch (inches per thread)
# --------------------------------------------------------------------------
# Thread output
# --------------------------------------------------------------------------
fmt  "P" 16  thddepth$      #Thread height absolute
fmt  "Q" 16  thdfirst$      #First depth cut in thread
fmt  "Q" 16  thdlast$       #Last depth cut in thread
fmt  "R" 2  thdfinish$      #G76 thread finish allowance
fmt  "R" 3  thdrdlt             #Thread R delta G92 and G76
fmt  "U" 3  thd_dirx            #Incremental X move for G76 mult starts
fmt  "W" 3  thd_dirz            #Incremental Z move for G76 mult starts
fmt  "P" 5  nspring$        #Number of spring cuts
fmt      5   thdpull            #G76 thread pull off
fmt      5   thdang             #G76 threading angle
# --------------------------------------------------------------------------
# Canned cycle output format (do not change order, used by buffer 2)
# --------------------------------------------------------------------------
fmt  "U" 2  depthcc
fmt  "R" 2  clearcc
fmt  "U" 2  xstckcc
fmt  "W" 2  zstckcc
fmt  "R" 4  ncutscc
fmt     2   stepcc
fmt  "P" 4  ng70s       #P line number in canned cycle
fmt  "Q" 4  ng70e       #Q line number in canned cycle
fmt  "U" 2  g73x        #Stored offset of canned cycle rough cut G73
fmt  "V" 2  g73y        #Stored offset of canned cycle rough cut G73
fmt  "W" 2  g73z        #Stored offset of canned cycle rough cut G73
fmt  "P" 2  grvspcc
fmt  "Q" 2  grvdpcc
# --------------------------------------------------------------------------
fmt "TOOL - "      4   tnote       # Note format
fmt "OFFSET - "    4   toffnote    # Note format
fmt "DIA. - "      1   tldianote   # Note format
fmt  "D" 25 tldia$                # Note format
fmt  "R" 25 tcr$                  # Note format
# --------------------------------------------------------------------------
fmt     4   year2       #Calculated year value
fmt     21  time2       #Capture 24-hour time value into 'time2' variable
fmt     22  hour        #Hour 
fmt     23  min         #Minutes
year2 = year$ + 2000

# --------------------------------------------------------------------------
# Parameter information lookup tables, see pparameter
# --------------------------------------------------------------------------
fprmtbl 1 5 #Rough cut parameters
        13343 depthcc
        10407 clearcc
        10202 xstckcc
        10203 zstckcc
        10214 directcc

fprmtbl 2 4 #Finish cut parameters
        13341 ncutscc
        10101 depthcc
        10102 xstckcc
        10103 zstckcc

fprmtbl 3 5 #Groove cut parameters
        13358 stepcc
        13138 directcc
        13352 dopeckcc
        10316 depthcc
        13364 clearcc

fprmtbl 104 4 #Thread cut parameters
        10811 xmaj_thd
        10813 zstrt_thd
        10814 zend_thd
        10819 face_thd

fprmtbl 17000   7   #Table Number, Size - Machine Definition parameter table
        17391   axis_label   #Axis label - 1=X,2=Y,3=Z
        17402   rot_dir      #Rotary direction
        17408   rot_index    #Index or continuous
        17409   rot_angle    #Index step
        17410   rot_type     #Rotary type
        17101   all_cool_off #First coolant off command shuts off ALL coolant options
        17102   v9_coolant   #Use V9 coolant option

# Control Definition Parameters 
fprmtbl 18000   1    #Table Number, Size
#       Param   Variable to load value into 
        18171   write_ops    #Enable write NC operation information

# Toolpath Group Parameters 
fprmtbl 19000   0    #Table Number, Size
#       Param   Variable to load value into 

pprep$          #Pre-process postblock - Allows post instructions after the post is parsed but before the NC and NCI file are opened.
#DO NOT ATTEMPT TO OUTPUT TO THE NC FILE IN THIS POSTBLOCK (OR ANY POSTBLOCKS YOU MAY CALL FROM HERE) BECAUSE THE NC OUTPUT FILE IS NOT YET OPENED!
      rd_cd$       #Read CD Parameters
      rd_mch_ent_no$ = 0  #Read only the machine base parameters (use to collect common parameters from CNC_MACHINE_TYPE)
      rd_md$       #Read machine definition parameters
      rd_tlpathgrp$
      if write_ops = 0, result=mprint(swriteopserror, 2) #Write NC Operation information MUST be enabled in CD

      if log_file, [
      error_msg$ = 0
      err_file$ = 4
      bug2$ = 40
      fastmode$ = no$ ]


pparameter$      #Information from parameters
      #"pwrttparam", ~prmcode$, ~sparameter$, e$
      if prmcode$ = 15145, metvals   = rpar(sparameter$,1)
      if prmcode$ = 15346, comp_type = rpar(sparameter$,1)
      if prmcode$ = 20103, stinsert2 = sparameter$
      if prmcode$ = 20110, stholder2 = sparameter$
      if prmcode$ = 10124, g71type = rpar(sparameter$,1)
      result = fprm (abs(lathecc))
     if prmcode$ = 15166, wkof = rpar(sparameter$, 1)       #5/29/08      
      if prmcode$ = 15148, spdnl = rpar(sparameter$, 1)     #5/29/08      
      if prmcode$ = 10034, sp_rpm = rpar(sparameter$, 1)  #5/29/08      

# --------------------------------------------------------------------------
pset_mach       #Set post switches by reading machine def parameters
      #Reset variables prior to MD read
      y_axis_mch = no$    #Reset to zero - Set from Axis Combination

      rd_mch_ent_no$ = syncaxis$  #Retrieve machine parameters based on current axis combination - read from .nci G950 line
      rd_md$       #Read machine definition parameters - calls pmachineinfo$

      #We only need these set at toolchange (and start of file).  No need to set them each time a user may call rd_md
      if rot_angle = zero, ctable = one #ctable zero will produce a divide by zero error, so force to one if zero in MD
        else, ctable = rot_angle

# --------------------------------------------------------------------------
# Machine definition and control definition parameter capture:
# --------------------------------------------------------------------------
pmachineinfo$   #Machine information parameters postblock
      #rd_mach is used to call pmachineinfo postblock and read the parameters of the selected axis
      #combination machine entity set in rd_mch_ent_no.
      #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
      #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters
      #"-->pmachineinfo", ~prmcode$, "  ", ~sparameter$, e$  #Do not uncomment if being called from pprep$ - see pprep comment

      #Read parameter lookup tables - 
      if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000) #Run the parameter table for Machine Definition Parameters
      #Leave lines below commented until you enter values in related lookup tables
      if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000) #Run the parameter table for Control Definition Parameters
      #if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000) #Run the parameter table for Toolpath Group Parameters

      if axis_label = 2, y_axis_mch = yes$    #Y axis in axis combination found
      if lock_out_y,  y_axis_mch  =  no$  #5/29/08

    v9_coolant = yes$   #jcw
#   all_cool_off = yes$  #jcw

# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
ptoolcomment    #Comment for tool
      if tool_info = 1 | tool_info = 3,
        [
        tnote = abs(t$)
        toffnote = tloffno$
        strtool$ = ucase(strtool$)
        stinsert2 = ucase(stinsert2)
        !spaces$
        spaces$ = zero
        scomm_str, *tnote, " ", *toffnote, scomm_end, e$
        if posttype$ = two, # Lathe toolpath operation
          [
          if tool_op$ = 64, # Drill operation
          scomm_str, *strtool$, scomm_end, e$
          else,
          scomm_str, *strtool$, " ", *stinsert, *stinsert2, scomm_end, e$
          ]
        else, # Mill toolpath operation
        scomm_str, *strtool$, scomm_end, e$
        spaces$ = prv_spaces$
        ]

pcomment$       #Comment from manual entry (must call pcomment2)
      pcomment2 #Required if doing boolean 'if' logic testing!

pcomment2       #Output Comment from manual entry
      scomm$ = ucase (scomm$)
      !spaces$
      spaces$ = zero
      if gcode$ = 1005, scomm_str, scomm$, scomm_end, e$  #Manual entry - as comment
      if gcode$ = 1006, scomm$, e$                        #Manual entry - as code
      if gcode$ = 1007, scomm_str, scomm$, scomm_end      #Manual entry - as comment with move NO e$
      if gcode$ = 1026, scomm$                            #Manual entry - as code with move NO e$
      if gcode$ = 1008 & scomm$ <> sblank, n$, 32, scomm_str, scomm$, scomm_end, e$  #Operation comment
      if gcode$ = 1054, scomm_str, scomm$, scomm_end, e$  #File Descriptor
      if toolchng,
        [
        if gcode$ = 1051, scomm_str, scomm$, scomm_end, e$  #Machine name
        if gcode$ = 1052, scomm_str, scomm$, scomm_end, e$  #Group comment
        if gcode$ = 1053, scomm_str, scomm$, scomm_end, e$  #Group name
        ]
      spaces$ = prv_spaces$

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------
ptime           #Convert 24-hour time format into 12-hour AM/PM format
      if time$ >= 13, time2 = (time$ - 12)
      else, time2 = time$
      hour = int(time2), min = frac(time2)
      *hour, ":", *min,
      if time$ > 12, " PM"
      else, " AM"

pheader_custom         #Start of file
      #if b_prompt, q1 #Get bar out value   #5/29/08
      #if bar_out, q2  # Get Z Bar Stop Value
      "%", e$
      !spaces$
      spaces$ = zero
     if not(progno$), progno$ = 1000
      *progno$, " ", scomm_str, sprogname$, scomm_end, e$
      #*progno$, e$
      n$, 32, scomm_str, "POSTED ", month$, "-", day$, "-", year$, 32,  ptime, scomm_end, e$
      #scomm_str, "PROGRAM NAME - ", sprogname$, scomm_end, e$
      #scomm_str, "DATE=DD-MM-YY - ", date$, " TIME=HH:MM - ", time$, scomm_end, e$ #Date and time output Ex. 12-02-05 15:52
      #scomm_str, "DATE - ", month$, "-", day$, "-", year$, scomm_end, e$  #Date output as month,day,year - Ex. 02-12-05
      #scomm_str, "DATE - ", *smonth, " ", day$, " ", *year2, scomm_end, e$ #Date output as month,day,year - Ex. Feb. 12 2005
      #scomm_str, "TIME - ", time$, scomm_end, e$  #24 hour time output - Ex. 15:52
      #scomm_str, "TIME - ", ptime, scomm_end, e$  #12 hour time output 3:52 PM
      #spathnc$ = ucase(spathnc$)
      #smcname$ = ucase(smcname$)
      #stck_matl$ = ucase(stck_matl$)
      #snamenc$ = ucase(snamenc$)
      #scomm_str, "MCX FILE - ", *smcpath$, *smcname$, *smcext$, scomm_end, e$
      #scomm_str, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, scomm_end, e$
      #scomm_str, "MATERIAL - ", *stck_matl$, scomm_end, e$
      spaces$ = prv_spaces$

lsof0$           #Start of file for tool zero, lathe
      lsof$

lsof$            #Start of file for non-zero tool number, lathe
        if bar_out, [
    svn = n$
    n$,  "(BAR FEED)", e$
    n$,  "M5", e$
    n$,  "G0 G40", e$
    n$,  "G53 Z6.", e$
    n$,  "G54", e$
    n$,  "T1010", e$
    n$,  "M6", e$
    n$,  "X0.", e$
    n$,  *z_pos, e$
    n$,  "M1", e$
    n$,  "M10 G04 U1.0", e$
    n$,  "M11 G04 U0.5", e$]

      sav_cc_1013 = cc_1013$                                   # 1/17/03
      if met_out, pbld, n$, *smetric, e$ #5/29/08
      ltlchg$

msof0$           #Start of file for tool zero, mill
      msof$

msof$            #Start of file for non-zero tool number, mill
        if bar_out, [
    svn = n$
    n$, 32, "(BAR FEED)", e$
    n$, 32, "M5", e$
    n$, 32, "G0 G40", e$
    n$, 32, "G53 Z6.", e$
    n$, 32, "G54", e$
    n$, 32, "T1010", e$
    n$, 32, "M6", e$
    n$, 32, "X0.", e$
    n$, 32, "Z0.", e$
    n$, 32, "M1", e$
    n$, 32, "M10 G04 U1.0", e$
    n$, 32, "M11 G04 U0.5", e$]
     if met_out, pbld, n$, *smetric, e$ #5/29/08
     mtlchg$

ltlchg$          #Toolchange, lathe
     prv_plane$ = -1        #5/29/08
     n$,  sgplane, e$
      if sof_flg, preadbuf
      if tool_op$ = 216, bar_flg = 1

     if sof_flg2 & force_wcs,[ n$, "G20 G95 G90 G99", e$
     n$, "G80 G40", e$
     n$, "G0 G53 Z6.", e$
     n$, pwcs, e$
     force_wcs = 0]

      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcc_capture   #Capture LCC ends, stop output RLCC
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from c1_xh
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      result = force(gcode$, gcode$) #5/29/08

     if not(sof_flg2), [
      n$, "G0 G40", e$
      pl_retract
      n$, sm01, e$]
      if mctcmnt, ptoolcomment  #5/29/08
      comment$
      if sp_select,  psp_select   #5/29/08
      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        start_xh = vequ(xh$)
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pwcs, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position
          pbld, n$, *sg28ref, *utzref, e$   # removed this *utxref, [if y_axis_mch, "V0."], 
          if home_type = zero, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      else,
        [
        pbld, n$, pwcs, e$
          ]
     if t_plus & spindle_no$,  tloffno$ = t$ + t_plus  #5/29/08
      toolno = t$ * 100 + tloffno$
      if not(synch_flg & tool_op$ = 67),     #Suppress tool output if cutoff during part xfer
        [
        if omitseq$ = 1 & tseqno > 0,
          [
          if tseqno = 2, n$ = t$
          pbld, *n$, [if home_type = -1, *sgcode], *toolno, [if not(mctcmnt), ], e$ #*strtool$, 
          n$, "M06", e$
          ]
        else, [pbld, n$, [if home_type = -1, *sgcode], *toolno, [if not(mctcmnt), ], e$ #*strtool$,
          n$, "M06", e$]
        ]
      
      ipr_actv$ = c1_ipr_actv
      #pbld, n$, pfsgplane, pfsgfeed, e$
      if mt_flg, pcaxis_off_l  #Postblock for lathe transition 
      pcom_moveb    #Reset machine position, set inc. from last position
      pcan
      if sub_spdl, psubspd
      else, psnglspd
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      #Added for 'css_start_rpm' logic (09/05/01)
      if css_start_rpm,
        pcssg50, pcss # CSS output AFTER a G97S???? RPM spindle startup
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
      plast
    sof_flg2 = 0

mtlchg$          #Toolchange, mill
     if sof_flg, preadbuf #5/29/08
     if sof_flg2 & force_wcs,[ n$, "G20 G95 G90 G99", e$
     n$, "G80 G40", e$
     n$, "G0 G53 Z6.", e$
     n$, pwcs, e$
     force_wcs = 0]
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcom_moveb    #Get machine position, set inc. from c1_xh
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      result = force(gcode$, gcode$) #5/29/08

      if not(sof_flg2), [
      n$, "G0 G40", e$
      if prv_posttype$ = two, n$, sm05, e$
      pm_retract
      n$, sm01, e$
      ]

      if mctcmnt, ptoolcomment  #5/29/08
      comment$
      if sp_select,  psp_select   #5/29/08
      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        start_xh = vequ(xh$)
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pwcs, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position/reference
          pbld, n$, *sg28ref,  *utzref, e$    # Removed This *utxref, [if y_axis_mch, "V0."],
          if home_type = zero, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      else,
        [
        pbld, n$, pwcs, e$
        ]

     if not(spindle_no$),  toolno = t$ * 100 + t$                                           #5/29/08
     else, toolno = t$ * 100 + t_plus                                                            #5/29/08
     if not(drl_offset) &  (opcode$ = 3 | opcode$ = 16), toolno = toolno - t$    #5/29/08

      if omitseq$ = 1 & tseqno > 0,
        [
        if tseqno = 2, n$ = t$
        strtool$ = ucase(strtool$)
        pbld, *n$, [if home_type = -1, *sgcode], *toolno, [if not(mctcmnt), 40, *strtool$, 41], e$
          n$, "M06", e$
        ]
      else, [pbld, n$, [if home_type = -1, *sgcode], *toolno, [if not(mctcmnt), 40, *strtool$, 41], e$
          n$, "M06", e$ ]

      pbld, n$, pfsgplane, pfsgfeed, e$

      pcom_moveb    #Reset machine position, set inc. from last position
      pcaxis_on_m   #Postblock for mill transition
      pcan
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      pbld, n$, pclampoff, e$        # Unclamp      

      if millcc,
        [
        cabs = 0
        pbld, n$, *sgcode,  pfcout, [if y_axis_mch, "Y0."], e$
        ]
      else,
        [
        prv_gcode$ = c9k                  #change modality for forced output
        pbld, n$, `sgcode, pfcout, e$     #` used in case indexing mode
        ]
      result = force(cabs, cabs)
      result = force(indx_out, indx_out)

      n$, pindex, e$
      pbld, n$, pclampbrake, e$  # Clamp      
      pcan1, pbld, n$, *sgcode, pfxout, e$
      pcan1, pbld, n$, *sgcode, pyout, pfzout, pscool, strcantext, e$
       g_spdir = 3
       n$, spindle_m, e$   #output w/o speed
#      pspindle
#      prpm
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
      prv_plane$ = -1        #5/29/08
      n$, sgplane, e$            #5/29/08
      if millcc, pmillccb #Set mill conversion
      plast
      sof_flg2 = 0

ltlchg0$         #Call from NCI null tool change, lathe
      toolchng0 = one
      copy_x = vequ(x$)
      start_xh = vequ(xh$)
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      result = force(gcode$, gcode$) #5/29/08
      comment$
      pcan
      if t_plus & spindle_no$,  tloffno$ = t$ + t_plus  #5/29/08
      toolno = t$ * 100 + tloffno$
      if home_type = -1,
        [
        prv_gcode$ = c9k
        pbld, n$, `sgcode, toolno, e$
        ]
      else, pbld, n$, toolno, e$
      pbld, n$, psgplane, e$
      pcaxis_off_l  #Postblock for lathe transition
      pspindle
      pnullspindle
      pbld, n$, pscool,e$
      force_flg = 0
      if not(g54g55) & home_type > one & workofs$ <> prv_workofs$, force_flg = 1
      if spindle_no$ <> last_spindle_no, force_flg = 1
      if force_flg,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, pwcs, e$
        pbld, n$, psgcode, pfxout, pfyout, pfzout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      #Output cutter comp before each finish pass of           # 1/17/03
      #finishing groove canned cyle                            # 1/17/03
      if gcode$ = one, plinout                                 # 1/17/03
      else,                                                    # 1/17/03  
        [                                                      # 1/17/03        
        if lathecc = 3, pbld, n$, sccomp, e$                   # 1/17/03
        if tool_op$ = 201, !cc_pos$                            # 5/28/04
        prapidout                                              # 1/17/03 
        ]                                                      # 1/17/03
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea
      c_msng$ #Single tool subprogram call
      toolchng0 = zero
      plast

mtlchg0$         #Call from NCI null tool change, mill
      toolchng0 = one
      if last_millcc & op_id$ <> last_op_id & (not(millcc) | cuttype <> last_cuttype), pmillcca #End mill conversion
      copy_x = vequ(x$)
      start_xh = vequ(xh$)
      pcom_moveb    #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      result = force(gcode$, gcode$) #5/29/08
      comment$
      pcan

     if not(spindle_no$),  toolno = t$ * 100 + t$                                           #5/29/08
    else, toolno = t$ * 100 + t_plus                                                            #5/29/08
    if not(drl_offset) &  (opcode$ = 3 | opcode$ = 16), toolno = toolno - t$    #5/29/08

      if home_type = -1,
        [
        prv_gcode$ = c9k                     #change modality for forced output
        pbld, n$, `sgcode, toolno, e$
        ]
      else, pbld, n$, toolno, e$

      pbld, n$, psgplane, e$
      pcaxis_on_m   #Postblock for mill transition
#      pspindle
#      pnullspindle

      pbld, n$, pscool,e$
      force_flg = 0
      if not(g54g55) & home_type > one & workofs$ <> prv_workofs$, force_flg = 1
      if spindle_no$ <> last_spindle_no, force_flg = 1

      if force_flg,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, pwcs, e$
        pbld, n$, pclampoff, e$  # Clamp Off
        if millcc & not(last_millcc), pbld, n$, *sgcode, "C0.", [if y_axis_mch, "Y0."], e$
        else,
          [
          prv_gcode$ = c9k                     #change modality for forced output
          pbld, n$, `sgcode, pfcout, e$        #` used in case indexing mode
          ]
          pindex
        pbld, n$, pclampbrake, e$  # Clamp
        pbld, n$, psgcode, pfxout, pfyout, pfzout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      else,
        [
        if op_id$ <> last_op_id & millcc & not(last_millcc),
          [
          pbld, n$, pclampoff, e$  # Clamp Off
          cabs = 0
          pbld, n$, *sgcode, pfcout, [if y_axis_mch, "Y0."], e$
          pbld, n$, pclampbrake, e$  # Clamp
          ]
        ]

      pbld, n$, pclampbrake0, e$

      if abs(cdelta), n$, pindex, e$
      ppos_cax_lin  #Position C axis, toolplane or CL

      if millcc,
        [
        pmillccb #Set mill conversion
        pcom_moveb
        ]
      if gcode$ = one, plinout
      else, prapidout
      pbld, n$, pclampbrake, e$
      pcom_movea    #Update previous, pcan2
      c_msng$ #Single tool subprogram call
      toolchng0 = zero
      plast

plast       #Keep track of previous values
      last_millcc = millcc
      last_op_id =  op_id$
      last_cuttype  = cuttype
      last_spindle_no = spindle_no$

ptoolend$        #Read from buffer 1 for prv_, current and next tool info
                          #end tool here, current and next valid
      bar_flg = 0   #5/29/08      
#////////////////////////////////////////////////////////////////////////   #5/29/08
      mr_ttl = abs(c1_mr1) + abs(c1_mr2)
      if mr_ttl & tool_op$ <> 67 & sub_spdl,[   #Simple Transfer
     n$, pnullstop, e$
      if v9_coolant, [coolant$ = zero
      pbld n$, pscool, e$]
#      n$, *sg28ref, *utxref, e$
      if abs(mr4$),[n$, "P0.", "M119", e$
      "main ", n$, *mr4$, "M19", e$]
      n$, *sg00, "G58", *mr1$, e$
      n$, *sunclmp_sub, e$
      n$, *sg01, *mr2$, "F20.", e$
      n$, *sclmp_sub, e$
      n$, *sunclmp_main, e$
      n$, *sg00, "B0", "M9", e$
      mr_ttl = 0]
      if mr_ttl & tool_op$ = 67,[  # this will end the pick off routine
      if v9_coolant, coolant$ = zero,  n$, pscool, e$   #removed *sg28ref, *utxref
      n$, *sg00, "B0", e$
      mr_ttl = 0]
#////////////////////////////////////////////////////////////////////////

      if toolend_flg,
        [
        sav_rev = rev #Axis Sub does not update to rev
        pcan
        if n1_gcode <> 1000,
          [
          if millcc, pmillcca #End mill conversion          
          toolno = t$ * 100 + zero
          sav_gcode = gcode$
          gcode$ = zero
          if v9_coolant & nextop$ <> 1002, [coolant$ = zero, pbld, n$, pscool, e$]
          if all_cool_off,
            [
            #all coolant off with a single off code here
            if coolant_on, pbld, n$, *sall_cool_off, e$
            coolant_on = zero
            ]
          else,
            [
            local_int = zero
            coolantx = zero
            while local_int < 20,
              [
              coolantx = and(2^local_int, coolant_on)
              local_int = local_int + one
              if coolantx > zero,
                [
                coolantx = local_int
                pbld, n$, scoolantx, e$
                ]
              coolantx = zero
              ]
            coolant_on = zero
            ]
        if nextop$ = 1003 & mi10$ = 1, [chute = 0
        n$, schute, e$
        chute = 1]
          if posttype$ = two, pl_retract
          else, pm_retract
         n$, schute, e$
          if n1_gcode <> 1003,
            [
#            if prog_stop = 1, pbld, n$, *sm01, e$
#            if prog_stop = 2, pbld, n$, *sm00, e$
            ]
          gcode$ = sav_gcode
          ]
        else, #Null toolchange
          [
          if n1_posttype <> posttype$, pcan1, pbld, n$, pnullstop, strcantext, e$
          ]
        pcan2
        #Update current variables to prv_ needed in comparisons
        !posttype$
        if rc1 < size1, preadcur_nxt
        ]

      # 1/17/03
      # When canned grooving, set cc_1013 to zero so that the cutter comp
      # value called out on the NCI 1013 line will be ignored.  cc_1013
      # should be restored to it's previous value in 'prcc_call_end'.
      if tool_op$ = 208 | tool_op$ = 62,                         # 1/17/03
        [                                                        # 1/17/03
        sav_cc_1013 = cc_1013$                                   # 1/17/03
        cc_1013$ = zero                                          # 1/17/03
        ]                                                        # 1/17/03      

pl_retract      #Retract tool based on next tool gcode, lathe (see ptoolend)
      cc_pos$ = zero
    if nextop$ <> 1002, [
      if home_type = one,
        [
        xh$ = vequ(start_xh)
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        if css_actv$ & css_end_rpm & not(lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$),
          [
          pspindle
          prpm
          ]
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, [if drop_offset, *toolno], strcantext, e$
        if lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$,
          [
          pbld, n$, pnullstop, e$
          ]
        ]
      else,
        [
        #Retract to reference return
        pbld, n$,  psccomp, e$
        if home_type = m_one & drop_offset, pbld, n$, *toolno, e$
        if css_actv$ & css_end_rpm & not(lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$),
          [
          pspindle
          prpm
          ]
         pcan1, pbld, n$, *sg28ref,  *utzref,  strcantext, e$
        if lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$,
          [
          pbld, n$, pnullstop, e$
          ]
        if home_type > m_one & drop_offset, pbld, n$, *toolno, e$
        ]
        ]

pm_retract      #Retract tool based on next tool gcode, mill (see ptoolend)
    if nextop$ <> 1002, [
      if home_type = one,
        [
        xh$ = vequ(start_xh)
        pmap_home   #Get home position, xabs
        if frc_cinit, cabs = zero
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        if frc_cinit, pbld, n$, pclampoff, e$
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, protretinc, [if drop_offset, *toolno], strcantext, e$
        if prv_posttype$ <> two, n$, pnullstop,  e$
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, psccomp, e$    #removed sgcode
        if home_type = m_one & drop_offset, pbld, n$, *toolno, e$
        if frc_cinit, pbld, n$, pclampoff, e$
        pcan1, pbld, n$,  protretinc, e$    # Removed  *sg28ref, *utxref, [if y_axis_mch, "V0."], 
        if prv_posttype$ <> two,  n$, pnullstop, strcantext, e$
        pcan1, pbld, n$, *sg28ref, *utzref, e$
        if home_type > m_one & drop_offset, pbld, n$, *toolno, e$
        ]
     ]

protretinc      #Reset the C axis revolution counter
      if frc_cinit,
        [
        rev = zero
        sav_rev = zero
        cabs = zero
        csav = zero
        c_wnd = zero
        prvc_wnd = zero
        indx_out = zero
        if c_axistype = one,
          [
          if home_type = one, pfcout
          else,
            [
            cinc = zero
            *cinc
            ]
          ]
        else,
          [
          pindxcalc
          if c_axistype = three,
            [
            indx_out = cabs
            pindex
            ]
          else, pfcout
          ]
        !csav, !cabs, !c_wnd
        ]

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool
#//////////////////////////////////
      if mr_ttl,[
      n$, "B0", e$
      mr_ttl = 0]
#//////////////////////////////////
     n$, "G80 G40", e$
      ptoolend$
      comment$
    if bar_out, [
    n$, "M50", e$
    n$, "M99", *svn, e$]
      n$, "M02", e$
      mergesub$
      clearsub$
      mergeaux$
      clearaux$
      "%", e$

pwcs            #G54+ coordinate setting at toolchange
    workofs$ = wkof
    if workofs$ = -1, workofs$ = 0
      if home_type >= one,
        [
        sav_frc_wcs = force_wcs
        if sub_level$ > 0, force_wcs = zero
        if not(g54g55) & (workofs$ <> prv_workofs$ | (force_wcs & toolchng)),       #Mcam Work Offset Logic
          [
          if sub_level$, result = mprint(swrkserror)
          if workofs$ < 6,
            [
            g_wcs = workofs$ + 54
            *g_wcs
            ]
          else,
            [
            p_wcs = workofs$ - five
            "G54.1", *p_wcs
            ]
          ]
        if g54g55 & (spindle_no$ <> last_spindle_no | (force_wcs & toolchng)),        #G54/G55
          [
          if sub_level$, result = mprint(swrkserror)
          if spindle_no$ = 0, "G54"
          else, "G55"
          ]
        force_wcs = sav_frc_wcs
        !workofs$
        ]

#Rc1 is used to flag the SOF, rc1 = two at SOF
pcaxis_off_l    #Toolchange C axis disable, lathe, check prv_ to current
      if prv_posttype$ <> two,
        [
        if synch_flg, pbld, n$, *sm24, *sm224, e$
        else,
          [
          if spindle_no$ = 0, pbld, n$, *sm24, e$
          else, pbld, n$, *sm224, e$
          ]
        ]

pcaxis_on_m     #Toolchange C axis enable, mill, check prv_ to current
      if (rc1 = two | prv_posttype$ = two | spindle_no$ <> last_spindle_no),
        [
        if synch_flg, pbld, n$, *sm23, *sm223, e$
        else,
          [
          if spindle_no$ = 0, pbld, n$, *sm23, e$
          else, pbld, n$,  *sm223, e$
          ]
        #if nextdc$ = three, pbld, n$, "M49", e$  #Disable tap
        ]

plcc_cc_pos     #Position for lathe canned cycle cutter comp. enable
                #Position saved in prcc_setup
      pe_inc_calc   #Update previous
      copy_x = vequ(sav_xa)
      pcom_moveb    #Get machine position, set inc. from previous
      #Force comp from the finish profile
      compok = one
      cc_pos$ = n1_cc_pos
      if gcode$ = zero, prapidout
      else, plinout
      lcc_cc_pos = zero

pgear           #Use spindle gear range, find gear from RPM at X min.
      if use_gear = one,
        [
        if lathtype = zero | lathtype = two, x_min$ = c1_x_max
        else, x_min$ = c1_x_min
        x_min$ = x_min$ + c1_tox  #Correction for workshift
        if x_min$ = zero, x_min$ = 0.001
        if css_actv$ = zero, gear_spd = speedrpm
        else, gear_spd = (conversion * g_speed) / (pi$ * abs(x_min$) * two)
        gear = frange(one, gear_spd)
        *gear
        ]

prpm            #Output for start spindle
      speed = speedrpm
      if posttype$ = two,  #Lathe mode spindle
        [
        if speed = zero,
          pbld, n$, pfspindle_l, e$  #RPM = '0', output just an 'M05'
        else,
          [
          if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1,
            [
            pbld, n$, pgear, e$
            pbld, n$, *sg97, e$
            ]
          else,
            [
            pbld, n$, pgear, e$
            pbld, n$, *sg97, *speed, [if toolchng, pfspindle_l], e$
            ]
          ]
        ]
      else,    #Milling mode spindle
        [
        #result = nwadrs(strp, speed) #Different letter than 'S' for mill spindle?
        if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1, pbld, n$, *sg97, e$
        else, pbld, n$, *sg97, *speed, *spindle_m, e$
        result = nwadrs(strs, speed) #Reset to 'S' for next single speeed output
        ]
      !css_actv$ #Added (8/27/2002)

prpmnull       #Output for RPM at NULL tlchg (don't force spindle 'M' code)
      speed = speedrpm
      if posttype$ = two,
        [
        if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1,
          [
          pbld, n$, pgear, e$
          pbld, n$, *sg97, e$
          ]
        else,
          [
          pbld, n$, pgear, e$
          pbld, n$, *sg97, *speed, pfspindle_l, e$
          ]
        ]
      else,
        [  #Milling mode spindle
        #result = nwadrs(strp, speed) #Different letter than 'S' for mill spindle?
        if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1, pbld, n$, *sg97, e$
        else, pbld, n$, *sg97, *speed, *spindle_m, e$
        result = nwadrs(strs, speed) #Reset to 'S' for next single speeed output
        ]
      !css_actv$ #Added (8/27/2002)


pcssg50         #Output Constant surface speed clamp
      if css_actv$, pbld, n$, *sg50, *maxss$, e$

pcss            #Output Constant surface speed
      speed = g_speed
      if css_actv$,
        [
        if css_start_rpm, pbld, n$, *sg9697, *speed, pspindle_l, !css_actv$, e$
        else, pbld, n$, *sg9697, *speed, pfspindle_l, !css_actv$, e$                 #Force if not called after G97
        ]
      !speed

pspindle_l
      if spdnl =  -1, spdnl = 0 #5/29/08
      spindle_no$ = spdnl    #5/29/08
      if not(synch_flg),
        [
        if spindle_no$ = 0, spindle_l
        else, spindle_ls
        ]
      else, spindle_l_synch

pfspindle_l
      if spdnl =  -1, spdnl = 0 #5/29/08
      spindle_no$ = spdnl    #5/29/08
      if not(synch_flg),
        [
        if spindle_no$ = 0, *spindle_l
        else, *spindle_ls
        ]
      else, *spindle_l_synch

#Toolchange setup, spindle output, pspindle must be called first
pnullspindle  #Null toolchange and dwell spindle change, g_speed is input
      if prv_css_actv$<>css_actv$ | prv_g_spdir<>g_spdir | prv_speed<>g_speed,
        [
        #(1/10/2003) - test for coolant OFF (with 'cool_w_spd' mode enabled)
        if posttype$ = two & cool_w_spd <> zero
          & coolant$ = zero & prv_coolant$ > zero, pbld, n$, pscool, e$

        #Switch G97/G96 or direction at null or dwell
        #Stop the spindle if direction changes
        if (prv_g_spdir <> g_spdir) & abs(prv_g_spdir - g_spdir) <> three,
            pbld, n$, pnullstop, e$
        if css_actv$,
          [
          speed = g_speed
          pnullg50
          if prv_speed <> speed | prv_g_spdir<>g_spdir | prv_css_actv$<>css_actv$, pcss #(09/05/01)
          ]
        else,
          [
          if (prv_speed<>g_speed | prv_g_spdir<>g_spdir | prv_css_actv$<>css_actv$)
             & g_speed, prpmnull #(09/05/01)
          ]
        ]
      else, pnullg50

pnullg50      #Change G50 clamp speed at null or dwell
      if prv_maxss$ <> maxss$ & css_actv$, pcssg50

pnullstop     #Stop spindle at null, dwell or tool end
    if lathe_stop | nextop$ = 1003 | posttype$ = 1, [
      sav_spdir = g_spdir
      if cool_w_spd = zero, g_spdir = one
      else, g_spdir = one + (fsg2(coolant$) * three)
      if prv_posttype$ = two, pspindle_l
      else,  spindle_m, e$
      g_spdir = sav_spdir
    ]

pspindle        #Spindle speed calculations for RPM
      if maxss$ = zero | maxss$ > max_speed, maxss$ = max_speed
      if css_actv$,
        [
        #Spindle speed calculations for strt_spd w/CSS
        speedx = abs(xa)
        if opcode$ = 104, speedx = abs(c1_x_min)
        if opcode$ = 105, speedx = abs(tcr$)
        if speedx < 0.001,speedx = 0.001
        speedrpm = (conversion * g_speed) / (pi$ * speedx * two)
        ]
      else, speedrpm = g_speed
      #zero indicates spindle off (not a mistake)
      if speedrpm,
        [
        if speedrpm > maxss$, speedrpm = maxss$
        if speedrpm < min_speed, speedrpm = min_speed
        ]
      #Spindle speed for RPM with lathe drill, thread
      if opcode$ = 104 | opcode$ = 105, css_actv$ = zero
      if css_actv$ = zero, g_speed = speedrpm

pset_g_speed    #Set the spindle control variables from the read variables
      g_speed = abs(ss$)
      if cool_w_spd, g_spdir = fsg3(spdir$) + (fsg2(coolant$) * 3)
      else, g_spdir = fsg3(spdir$)
      if g_speed = zero, g_spdir = one # if RPM = '0', output 'M05' 
      if spd_rev, pswtchspin

pswtchspin      #Reverse spindle direction
      if g_spdir > two, g_spdir = abs (g_spdir - five) + three
      else, g_spdir = abs (g_spdir - two)

pclampbrake   #by operation     # clamp_code 0=clamp, 1=brake, 2=off
                                # clamp_flg  0=clamp, 1=brake, 2=off
                                # mi7 - Clamp Code Override
                                #       0 = Default post decision
                                #       1 = Force Full Clamp
                                #       2 = Force Brake / Mid-Clamp
                                #       3 = Off 


      #if cuttype = one, pxyzcout0                   #Turning                     off
      #if abs(cuttype) = two                         #Right/Left Face cut         brake unless rotary type is off (0) or Y (3)
      #| abs(cuttype) = three, pxyzcout2             #Cross cut                   brake/clamp
      #if cuttype = four, pxyzcout4                  #Y axis substitution         brake
      #if cuttype = five, pxyzcout5                  #Multisurf Rotary            brake

     if use_clamp | use_brake,
       [
       clamp_code = 2
       if cuttype = 1 | abs(cuttype) = 3 | (abs(cuttype) = 2 & (rotary_type$ = 0 | rotary_type$ = 3) & not(millcc)), clamp_code = 0       #clamp
       if abs(cuttype) = 2 | abs(cuttype) = 3 | cuttype = 4 | cuttype = 5 | millcc,
         [
         if clamp_code <> 0, clamp_code = 1      #brake
         ]
       if opcode$ = 3 | opcode$ = 16, clamp_code = 2
       if use_clamp = 0 & clamp_code = 0, clamp_code = 2
       if use_brake = 0 & clamp_code = 1, clamp_code = 2
       if mi7$, clamp_code = mi7$ - 1
       if synch_flg, smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, smspdl_clmp
         if spindle_no$ = 1, smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

pclampbrake0                     # clamp_code 0=clamp, 1=brake, 2=off
     if (use_clamp | use_brake) & clamp_flg = 0,
        [
        if fmtrnd(cabs) <> prv_cabs, clamp_code = 2
        if mi7$, clamp_code = mi7$ - 1
        if synch_flg, smspdl_clmp_synch
        else,
          [
          if spindle_no$ = 0, smspdl_clmp
          if spindle_no$ = 1, smspdl_clmps
          ]
        clamp_flg = clamp_code
        ]

pfclampon      #Force clamp on
     if use_clamp | use_brake,
       [
       clamp_code = 0
       if mi7$, clamp_code = mi7$ - 1
       if synch_flg, *smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, *smspdl_clmp
         if spindle_no$ = 1, *smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

pfclampoff      #Force clamp off
     if use_clamp | use_brake,
       [
       clamp_code = 2
       if synch_flg, *smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, *smspdl_clmp
         if spindle_no$ = 1, *smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

pclampoff       #Clamp off
     if spindle_no$ <> last_spindle_no, pfclampoff
     if use_clamp | use_brake,
       [
       clamp_code = 2
       if synch_flg, smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, smspdl_clmp
         if spindle_no$ = 1, smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

preadcur_nxt    #Read current and next tool record
      c1_gcode = rbuf (one, rc1)     #Current tool record
      #Place buffered variables in post global variables
      cuttype = c1_cuttype
      lathtype = c1_lathtype
      lathecc = c1_lathecc
      gcodecc = c1_gcodecc
      y_axis = c1_y_axis
      millcc = c1_millcc
      n1_gcode = rbuf (one, nc1)     #Next tool record
      if cuttype = one, cc_1013$ = one
      else, cc_1013$ = zero
      if lathecc<>zero & lathecc<>4, compok = zero
      else, compok = one

ptlchg1002$      #Call at actual toolchange with tlchng_aft
      whatline$ = four #Required for vector toolpaths
      pset_mach   #Set rotary switches by reading machine def parameters
      pmatrix_su
      pmap_plane
      pset_turret
      pset_g_speed
      toolend_flg = one
      if gcode$ = 1000,
        [
        #Null toolchange
        #if millcc & prv_mi4$ = mi4$, cutpos2$ = sav_cutpos2
        if cc_stop_fcc & rcc_flg$ = 6, no_nc_out$ = one
        ]
      else,
        [
        #Toolchange and Start of file
        if gcode$ = 1002,
          [
          #Actual toolchange
          preset_mod
          ]
        prv_xia = vequ (c1_xh)
        prv_feed = c9k
        pnt_at_zero = zero
        ]
      #Mill canned cycle initialze at toolchange
      arcoutput$ = sav_arcout
      if millcc,
        [
        #R arc output
        arcoutput$ = one
        if cuttype = four,
          [
          if g107crad = 0, crad = rotdia$/two
          else, crad = rotdia$
          ]
        else,
          [
          breakarcs$ = zero
          ]
        ]
      iout = zero
      kout = zero
      !mi4$

preset_mod    #Reset the mode flags and map during motion blocks
      breakarcs$ = breakarcss
      cir_at_zero = zero
      linarc$ = zero
      brklinestype$ = zero

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------
prapidout       #Output to NC, linear movement - rapid
      if interp_flg & (abs(cuttype) = 4 | abs(cuttype) = 2) & cutpos2$ = 0,
        [
        if abs(cuttype) = 4,   #position C then XZ for approach to interpolation on the OD
          [
         pcan1, pbld, n$, psgplane, pexct, psgcode, pcout, pscool, strcantext, e$
           pbld, n$, pexct, pxout, pyout, pzout, e$
          ]
        else,                 #position C and X then Z for approach to interpolation on the face
          [
           pcan1, pbld, n$, psgplane, pexct, psgcode, pxout, pcout, pyout, pscool, strcantext, e$
          pbld, n$, pzout, e$
          ]
        ]
      else,
        [
        if opcode$ = 3,  pbld, n$, pcout, e$  #Fixes issue with longhand drilling output, cam/wbt
        pcan1, pbld, n$, psgplane, pexct, psgcode, pxout, pyout,
          pzout, pcout, pscool, strcantext, e$
        ]

plinout         #Output to NC, linear movement - feed
      #Output the Z after XY so the tool can move to position before plunging
      #helps for toolpaths not starting near the 3o'clock position
      if interp_flg & abs(cuttype) = 2 & cutpos2$ = 0,
        [
        pcan1, pbld, n$, psgplane, psgfeed, pexct, psgcode, psccomp, pxout,
          pyout, pcout, pfr, pscool, strcantext, e$
         pbld, n$, psgfeed, psgcode, pzout, pfr, e$
        ]
      else,
        [
        if opcode$ = 3,  pbld, n$, pcout, e$  #Fixes issue with longhand drilling output, cam/wbt
         pcan1, pbld, n$, psgplane, psgfeed, pexct, psgcode, psccomp, pxout,
          pyout, pzout, pcout, pfr, pscool, strcantext, e$
        ]

pcirout   #Output to NC, circular interpolation
      pcan1, pbld, n$, psgplane, psgfeed, pexct, psgcode, psccomp, pxout,
        pyout, pzout, pcout, parc, pfr, pscool, strcantext, e$

pl_ncoutput     #Movement output
      pcc_capture   #Capture LCC ends, stop output RLCC          # 05/28/04   #This was previously commented out but I have removed that as it affects G73 pattern repeat.  I'm not sure what else this affects at this point. WBT
      pcom_moveb    #Get machine position, set inc. from last position
      pcan
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2

pm_ncoutput     #Movement output
      if millcc, pmillccb #Set mill conversion   #set here so coordinate calc is consitent with state of G112
      pcom_moveb    #Get machine position, set inc. from last position
      pcan
      pindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      pcom_movea    #Update previous, pcan2
      ppos_pnt_zero #Update to detect point at zero

pdwl_spd$        #Output to NC, spindle, dwell changes
      pset_g_speed
      pspindle
      comment$
      pnullspindle
      pcan
      if fmtrnd(dwell$), pdwell1
      else, pcan1, pbld, n$, strcantext, e$
      pcan2

mrapid$          #Output to NC of linear movement - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pzrapid$         #Linear movement in Z axis only - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pz$              #Linear movement in Z axis only - at feedrate, mill
      copy_x = vequ(x$)
      pm_ncoutput

mlin$            #Output to NC of linear movement - feed, mill
      copy_x = vequ(x$)
      pm_ncoutput

mcir$            #Output to NC of circular interpolation, mill
      pshft_map_ijk
      copy_x = vequ(x$)
      pm_ncoutput

lrapid$          #Rapid linear movement, lathe
      copy_x = vequ(x$)
      if lathecc = 3, pbld, n$, sccomp, e$        # 1/17/03
      if not(bar_flg), pl_ncoutput   #5/29/08

llin$            #Linear line movement - at feedrate, lathe
      copy_x = vequ(x$)
      pl_ncoutput

lcir$            #Circular interpolation, lathe
      pshft_map_ijk
      copy_x = vequ(x$)
      pl_ncoutput

pmx$             #Output to NC of Multisurf Rotary, mill
      copy_x = vequ(x$)
      pm_ncoutput

#Pre-process rotary motion control flags, mill
pmx0$            #5 ax Drill
      if cuttype = five,
        [
        if drill5$ = one, z$ = initht$ * z_mult
        else,
          [
          if fr$ =  -2,gcode$ = zero
          else, gcode$ = one
          ]
        ]
plin0$           #Pre-linear movement postblock
      if posttype$ <> two,
        [
        preset_mod
        if y_axis = zero & millcc = zero & c_axistype <> three,
          [
          #Set brklinestype
          if abs(cuttype) = two & (cutpos2$ >= 2 & cutpos2$ <= 4), brklinestype$ = 6  #Break XY (machine coord sys) motion on during face cut
          if abs(cuttype) = three & (cutpos2$ >= 2 & cutpos2$ <= 4), brklinestype$ = 4  #Break XY (machine coord sys) motion on during cross cut                        
          #if abs(cuttype) = two, brklinestype$ = 6
          #if cuttype = three, brklinestype$ = four
          ]
        ]

pcir0$           #Pre-circular interpolation postblock
      pmap_plane
      if posttype$ <> two,
        [
        preset_mod
        pshft_map_xc
        if y_axis = zero & millcc = zero,
          [
          #Set linarc, breakarcs and cir_at_zero
          if fmtrnd(xca) = zero & fmtrnd(yca) = zero,
            [
            #Set breakarcs and cir_at_zero
            #if rot_type = 2 & abs(cuttype) = 2, breakarcs$ = 1
            #we want all arcs about X0Y0 to be broken regardless of rot_type            
            #This helps with side plane, rotary axis one, full arcs when arcs get converted to rotary motion
            if abs(cuttype) = 2, breakarcs$ = 2      #this can be changed between 1 (quadrants) and 2 (180 deg)   
            else, breakarcs$ = zero
            #C axis move
            if mach_plane = zero,
              [
              cir_at_zero = one
              czero_csav = csav
              ]
            #Arc output
            if mach_plane = two, cir_at_zero = m_one
            ]
          if cir_at_zero = zero, linarc$ = one
          ]
        if millcc & plane$ <> 0, linarc$ = one
        ]
      !ynci$

# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
pdwell1         #Dwell output
      gcode$ = four  #for implied dwells
      pcan1, pbld, n$, *sgcode, *dwell$, strcantext, e$

pbld            #Canned text - block delete
      if bld, '/'

pfbld           #Force block delete
      "/"

psgplane        #Machining plane
      if (gcode$ = 2 | gcode$ = 3) & plane$ <> prv_plane$, result = force(gcode$,gcode$)
      if y_axis_mch & not(millcc) & posttype$ <> 2, sgplane   #plane changes between 0 and 2 for turning, only allow output at toolchange, never allow plane output during G07.1 or G12.1
      !plane$

pfsgplane       #Force machining plane
      if (gcode$ = 2 | gcode$ = 3) & plane$ <> prv_plane$, result = force(gcode$,gcode$)
      if y_axis_mch | (millcc & cuttype = 4), *sgplane    #force plane output before G07 whether Y-axis or not, never allow plane output during G07.1 or G12.1
      !plane$

psgfeed
      if posttype$ = 1 & mi6$ = 1, ipr_actv$ = 1
      if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3,
        [
        if use_pitch = 1, ipr_actv$ = 1
        else, ipr_actv$ = 0
        ]
      sgfeed

pfsgfeed
      if posttype$ = 1 & mi6$ = 1, ipr_actv$ = 1
      if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3,
        [
        if use_pitch = 1, ipr_actv$ = 1
        else, ipr_actv$ = 0
        ]
      *sgfeed

pexct           #Canned text - exact stop
      if exact, 'G9'

psgcode         #Output the Gcode based on the current plane
      if c_ax_flp,
        [
        #Reverse arc direction for c_axis flip
        if gcode$ = two | gcode$ = three,
          [
          sav_gcode = gcode$
          gcode$ = (5 - gcode$)  #G02->G03 or G03->G02    # 1/17/03
          ]
        ]
      if plane$ = zero, `sgcode
      if plane$ = one, `sgcode1
      if plane$ = two, `sgcode2
      if c_ax_flp, gcode$ = sav_gcode

psccomp         #Output the cutter compensation based on the current plane
      if compok,
        [
        if plane$ = zero, sccomp
        if plane$ = one, sccomp1
        if plane$ = two, sccomp2
        ]

pfxout          #Force X axis output
      if absinc$ = zero, *xabs, !xinc
      else, *xinc, !xabs

pxout           #X output
      if absinc$ = zero, xabs, !xinc
      else, xinc, !xabs

pfyout          #Force Y axis output
      if y_axis_mch,                    #Allow Y in the force out so it can come out before and after G112
        [
        if absinc$ = zero, *yabs
        else, *yinc
        ]
      if not(y_axis_mch), pchecky
      !yabs, !yinc

pyout           #Y output
      if y_axis_mch & not(millcc),
        [
        if absinc$ = zero, yabs
        else, yinc
        ]
      if not(y_axis_mch), pchecky
      !yabs, !yinc

pchecky         #Y output should not happen on a c-axis lathe
      if not(toolchng) & yinc & checkyflg,
        [
        result = mprint(symoterror, 2)
        checkyflg = no$
        ]
pfzout          #Force Z axis output
      if absinc$ = zero, *zabs, !zinc
      else, *zinc, !zabs

pzout           #Z output
      if absinc$ = zero, zabs, !zinc
      else, zinc, !zabs

pfcout          #Force C axis output
      if spindle_no$ = 0,                       #main
        [
        result = nwadrs(strc,cout_a)
        result = nwadrs(strh,cout_i)
        if millcc & g112address = 0, result = nwadrs(stry, cabs)
        if millcc & g112address = 1, result = nwadrs(strc, cabs)
        ]
       else,                                   #sub
        [
        result = nwadrs(stra, cout_a)
        if millcc & g112address = 0, result = nwadrs(stry, cabs)
        if millcc & g112address = 1, result = nwadrs(stra, cabs)
        ]

      cout_a = cabs
      cout_i = csav - prv_csav

      if rot_type = 2,
        [
        while cout_a >= 360, cout_a = cout_a - 360
        while cout_a < 0, cout_a = cout_a + 360
        ]

      if posttype$ <> two & c_axistype < three,
        [
        if c_axistype = one | millcc,
          [
          if (abs(cuttype) = 3 | cuttype = 4) & rot_type = 2,
            [
            if absinc$ = one | (abs(fmtrnd(csav - prv_csav)) >= 180. & gcode$ <> 0), *cout_i, !cinc, !cabs, !cout_a
            else, *cout_a, !cabs, !cinc, !cout_i
            ]
          else,
            [
            if millcc,
              [
              if absinc$ = zero, !cout_a, *cabs, !cinc, !cout_i
              else, !cout_i, *cinc, !cabs, !cout_a
              ]
            else,
              [
         c_del = fmtrnd(abs(cout_a) - abs(prv_cout_a))  #5/29/08
         !c_del                                                             #5/29/08
         if spdnl & c_del,[ p_ang = cabs                            #5/29/08
          "M119", p_ang                                         #5/29/08
         !cout_a, !cabs, !cinc, !cout_i]                                #5/29/08
         else, [                                                                #5/29/08
              if absinc$ = zero, *cout_a, !cabs, !cinc, !cout_i
              else, *cout_i, !cinc, !cabs, !cout_a
            ]                                                                       #5/29/08
              ]
            ]
          ]
        else, #Signed direction, modality on c_wnd, no incremental
          [
          if fmtrnd(prv_c_wnd) <> fmtrnd(c_wnd),
            [
            if indx_mc = zero, result = nwadrs(sc_minus, cout_a)
            else, result = nwadrs(str_cax_abs, cout_a)
            *cout_a
            ]
          !c_wnd, !cabs, !cinc
          ]
        ]
      !csav

pcout           #C axis output
      if spindle_no$ = 0,                       #main
        [
        result = nwadrs(strc,cout_a)
        result = nwadrs(strh,cout_i)
        if millcc & g112address = 0, result = nwadrs(stry, cabs)
        if millcc & g112address = 1, result = nwadrs(strc, cabs)
        ]
       else,                                   #sub
        [
        result = nwadrs(stra,cout_a)
        if millcc & g112address = 0, result = nwadrs(stry, cabs)
        if millcc & g112address = 1, result = nwadrs(stra, cabs)
        ]

      cout_a = cabs
      cout_i = csav - prv_csav

      if rot_type = 2,
        [
        while cout_a >= 360, cout_a = cout_a - 360
        while cout_a < 0, cout_a = cout_a + 360
        ]

      if posttype$ <> two & c_axistype < three,
        [
        if c_axistype = one | millcc,
          [
          if (abs(cuttype) = 3 | cuttype = 4) & rot_type = 2,
            [
            if absinc$ = one | (abs(fmtrnd(csav - prv_csav)) >= 180. & gcode$ <> 0), *cout_i, !cinc, !cabs, !cout_a
            else, cout_a, !cabs, !cinc, !cout_i
            ]
          else,
            [
            if millcc,
              [
              if absinc$ = zero, !cout_a, cabs, !cinc, !cout_i
              else, !cout_i, cinc, !cabs, !cout_a
              ]
            else,
              [
         c_del = fmtrnd(abs(cout_a) - abs(prv_cout_a))  #5/29/08
         !c_del                                                             #5/29/08
         if spdnl & c_del,[ p_ang = cabs                            #5/29/08
          "M119", p_ang                                                 #5/29/08
         !cout_a, !cabs, !cinc, !cout_i]                                #5/29/08
         else, [                                                                #5/29/08
              if absinc$ = zero, cout_a, !cabs, !cinc, !cout_i
              else, cout_i, !cinc, !cabs, !cout_a
              ]                                                                 #5/29/08
              ]
            ]
          ]
        else, #Signed direction, modality on c_wnd, no incremental
          [
          if fmtrnd(prv_c_wnd) <> fmtrnd(c_wnd),
            [
            if indx_mc = zero, result = nwadrs(sc_minus, cout_a)
            else, result = nwadrs(str_cax_abs, cout_a)
            *cout_a
            ]
          !c_wnd, !cabs, !cinc
          ]
        ]
      !csav

pindex          #Index output
      if c_axistype = three,
        [
       if indx_out <> prv_indx_out, `sindx_mc, indx_out
        !cabs, !cinc, !indx_out
        ]

pindexdrl          #Index output
      if c_axistype = three,
        [
       if indx_out <> prv_indx_out, `sindx_mc, indx_out
        !cabs, !cinc, !indx_out
        ]

parc            #Select the arc output
      #Setup for arctype setting
      if (posttype$ = 2 & (larctypexz$ = one | larctypexz$ = four)) |
        (posttype$ = 1 &(plane$ = zero & (arctype$ = one | arctype$ = four)) |   #XY Plane
        (plane$ = one & (arctypeyz$ = one | arctypeyz$ = four)) | #YZ Plane
        (plane$ = two & (arctypexz$ = one | arctypexz$ = four))),  #XZ Plane
        [
        result = newfs(two, i$)
        result = newfs(two, j$)
        result = newfs(two, k$)
        result = newfs(two, iout)
        result = newfs(two, jout)
        result = newfs(two, kout)
        ]
      else,
        [
        result = newfs(three, i$)
        result = newfs(three, j$)
        result = newfs(three, k$)
        result = newfs(three, iout)
        result = newfs(three, jout)
        result = newfs(three, kout)
        ]

      if ((posttype$ = 2 & (plane$ = 2 & larctypexz$ < five)) |
        (posttype$ = 1 & ((plane$ = 0 & arctype$ < five) |
        (plane$ = 1 & arctypeyz$ < five) |
        (plane$ = 2 & arctypexz$ < five)))) & not(cuttype = 4 & millcc),
        [
        #Arc output for IJK
        if (posttype$ = 2 & (plane$ = 2 & larctypexz$ = one)) |   #XZ plane - Lathe
          (posttype$ = 1 & ((plane$ = zero & arctype$ = one) |    #XY Plane - Mill
          (plane$ = one & arctypeyz$ = one) |                     #YZ Plane - Mill
          (plane$ = two & arctypexz$ = one))),                    #XZ Plane - Mill
          [
          #Arc output for IJK, absolute
          iout = (iout + dia_shift) * dia_mult
          jout = (jout + y_shift) * y_mult
          kout = (kout + z_shift) * z_mult
          if c_ax_flp, iout = -iout
          ]
        else,
          [
          #Arc output for IJK, start/center
          iout = iout * (dia_mult/abs(dia_mult))
          jout = jout * y_mult
          kout = kout * z_mult
          if c_ax_flp, iout = -iout
          ]
        #If you do NOT want to force out the I,J,K values,
        #remove the "*" asterisks on the *i, *j, *k 's below...
        if plane$ = zero, *iout, *jout, kout #XY plane code - G17
        if plane$ = one, iout, *jout, *kout  #YZ plane code - G19
        if plane$ = two, *iout, jout, *kout  #XZ plane code - G18          
        #Original method does not force out IJK values of 0 for delta start to centre arcs  
        #iout, kout, jout
        !i$, !j$, !k$
        ]
      else,
        [
        #Arc output for R
        if abs(sweep$)<=180 | cuttype = 4 & millcc |
          (posttype$ = 2 & (plane$ = 2 & larctypexz$ = five)) |               #XZ Plane - Lathe
          (posttype$ = 1 & ((plane$ = 0 & arctype$ = five) |                  #XY Plane - Mill
          (plane$ = 1 & arctypeyz$ = five) |                                  #YZ Plane - Mill
          (plane$ = 2 & arctypexz$ = five))), result = nwadrs(strr, arcrad$)  #XZ Plane - Mill
        else, result = nwadrs(srminus, arcrad$)
        *arcrad$
        ]

pffr            #Output feedrate, force
      if posttype$ = 1 & mi6$ = 1, ipr_actv$ = 1
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      if tap_feed = one & drillcyc$ = three, result = newfs (18, feed)  #Tap feeds with 4/3 decimal places
      *feed

pfr             #Output feedrate
      if posttype$ = 1 & mi6$ = 1, ipr_actv$ = 1
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      if tap_feed = one & drillcyc$ = three, result = newfs (18, feed)  #Tap feeds with 4/3 decimal places 
      `feed

pfr_m           #Format feedrate for mill
      result = nwadrs(strf, feed)
      result = newfs (17, feed)

pfr_l           #Format feedrate for lathe
      if opcode$ = 104,
        [
        #Format feedrate for lathe thread
        if thread_address,
          [
          result = nwadrs(stre,feed)
          ]
        else,
          [
          result = nwadrs(strf,feed)             #Default as per Fanuc programming manual
          ]
        result = newfs (19, feed)
        ]
      else,
        [
        result = nwadrs(strf, feed)
        result = newfs (18, feed)
        if mi6$, result = newfs (12, feed)
        ]

pscool          #Coolant is separate code
      if v9_coolant,
        [
        if cool_w_spd = zero, scoolant
        else,
          [ # 'cool_w_spd' mode is active - (1/10/2003)
          if coolant$ = zero, scoolant  #Turn coolant OFF
          ]
        !coolant$
        ]

pfscool         #Coolant is separate code, force
      if v9_coolant,
        [
        if cool_w_spd = zero, *scoolantx
        !coolant$
        ]

pcc_capture     #Capture ends of canned turning path, stop output w/rough
      #Stop output in rough only lathe canned cycles
      #between rough and finish paths
      #if cc_stop_fcc & rcc_flg$ = 6, no_nc_out$ = one          # 05/28/04
      if cc_stop_fcc & rcc_flg$ = 6 & lathecc <> 2, no_nc_out$ = one          #wbt - do not want to stop output before/after pattern repeat
      #Capture vector for G73 cycle
      if rpd_typ$ = 6 & abs(lathecc) = two,
        [
        if rcc_flg$ = one, lcc_xcst = vequ (copy_x)
        if rcc_flg$ = three, lcc_xcend = vequ (copy_x)
        ]

pcom_moveb      #Common motion preparation routines, before
      pshft_map_xa
      pxyzcout
      if interp_flg = 1 & millcc,
        [
        #Change rapid to highest possible feedrate
        if gnci$ = zero,
          [
          gcode$ = one
          feed = maxfeedpm
          result = force(feed,feed)
          ]
        ]
      ps_inc_calc

ppos_cax_lin    #Position C if from CL
      if (prv_pnt_at_zero) & c_axistype < three,
        [
        #Output to NC, C axis movement only - rapid deg/min
        sav_gcode = gcode$
        sav_feed = feed
        gcode$ = one
        if millcc = zero,
          [
          feed = maxfrdeg
          pbld, n$, psgcode, pfcout, pffr, e$
          ]
        else, pbld, n$, psgcode, pfcout, pfr, e$
        gcode$ = sav_gcode
        feed = sav_feed
        ]

pcom_movea      #Common motion preparation routines, after
      pcan2
      pe_inc_calc

ppos_pnt_zero   #Position C if from CL
      !pnt_at_zero
      pnt_at_zero = zero

#Mill canned cycle output
pmillccb        #Cross/Face canned cycle code, before
      if interp_flg = 0,
        [
        interp_flg = 1
        result = newfs(two, cabs)
        result = newfs(two, cinc)
        #Cross/Face canned cycle start code
        if abs(cuttype) = two,
          [
          #Face canned cycle start code, G112 (break ramp)
          #Fanuc style uses X diameter, C radius
          pbld, n$, *sg112, e$
          prv_xabs = c9k
          prv_xinc = c9k
          prv_cabs = c9k
          prv_cinc = c9k
          compok = one
          ]
        else,
          [
          #Cross canned cycle start code
          #Fanuc Style, G107 is new style, G07.1 is older style
          #Here X is in radius ccords and the toolpath is executed in C (Y coord) and Z
          pbld, n$, pfsgplane, "H0.", "W0.", e$
          pbld, n$, *sg107, *crad, e$
          ]
        ]

pmillcca        #Cross/Face canned cycle code, after
      #cancel at end of op only regardless of whether or not the next op
      if interp_flg,
        [
        interp_flg = 0
        #Cross/Face canned cycle end code
        result = newfs(12, cabs)
        result = newfs(14, cinc)
        !cabs
        cabs = 0
        if abs(last_cuttype) = two,   #Face
          [
          #Fanuc Style
          pbld, n$, *sg113, e$
          ]
        else,                         #Cross
          [
          #Fanuc Style
          pbld, n$, *sg108, pfcout, e$
          ]
        cabs = prv_cabs
        ]

# --------------------------------------------------------------------------
# Drilling
# --------------------------------------------------------------------------
pdrill0$         #Pre-drill postblock call
      if cuttype = five, #Don't allow 5 axis, rests at toolchange
        [
        usecandrill$ = zero
        usecanpeck$ = zero
        usecanchip$ = zero
        usecantap$ = zero
        usecanbore1$ = zero
        usecanbore2$ = zero
        usecanmisc1$ = zero
        usecanmisc2$ = zero
        ]
      else,
        [
        if abs(cuttype) < three, mdrl_dir = zero
        else, mdrl_dir = one
        x$ = xnci$
        y$ = ynci$
        z$ = refht$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        refht_x = vequ(xabs)
        z$ = depth$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        depth_x = vequ(xabs)
        z$ = zdrl$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        zdrl_x = vequ(xabs)
        z$ = initht$  #Initial is last
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        initht_x = vequ(xabs)
        znci$ = initht$
        ps_inc_calc
        ]

pdrlcommonb     #Canned Drill Cycle common call, before
      if gcode$ = 81,
        [
        if drillcyc$ = three, drlgsel = fsg1 (-g_speed) + drillcyc$ * two #Tap
        else, drlgsel = fsg2 (dwell$) + drillcyc$ * two
        if initht$ <> refht$, drillref = zero
        else, drillref = one
        prv_refht_a = c9k
        prv_refht_i = c9k
        prv_dwell$ = zero
        ]
      if mdrl_dir = zero, #Set Z to depth
        [
        zia = fmtrnd(depth_z)
        zinc = zia - prv_zia
        ]
      else,               #Set X to depth
        [
        xia = fmtrnd(depth_x)
        xinc = xia - prv_xia
        ]
      xabs = vequ (depth_x)
      comment$
      pcan

pgdrlout        #Drill Gcode output
      if mdrl_dir = zero, *sgdrillf
      else, *sgdrillc

prdrlout        #R drill position
      if mdrl_dir = zero,
        [
        refht_a = refht_z
        refht_i = refht_a - initht_z
        ]
      else,
        [
        refht_a = refht_x
        refht_i = (refht_a - initht_x) / dia_mult
        ]

    if not(inc_r), [
      if absinc$ = zero, refht_a, !refht_i
      else, refht_i, !refht_a
         ]
      else, refht_i, !refht_a            #Fanuc is always incremental from initial height 

ldrill$          #Canned drill cycle, lathe
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, dwell$, pffr, strcantext, e$
      pcom_movea
      pcanceldcl

lpeck$           #Canned peck drill cycle, lathe
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, *peck1$, dwell$, pffr, strcantext, e$
      pcom_movea
      pcanceldcl

lchpbrk$         #Canned chip break cycle, lathe
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, *peck1$, dwell$, pffr, strcantext, e$
      pcom_movea
      pcanceldcl

ltap$            #Canned tap cycle, lathe
      pdrlcommonb
      if use_pitch = 0, #Feed/Min mode, feed divided by spindle speed is equal to thread lead 
        [
        if rigid_tap, pbld, n$, *sm29, *speed, e$           #Rigid Tapping    Can use G84/G88 with M29 or just G84.2
        pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
          prdrlout, dwell$, pffr, strcantext, e$
        ]
      else, #Feed/Rev mode, feed is equal to thread lead 
        [
        if rigid_tap, pbld, n$, *sm29, *speed, e$           #Rigid Tapping    Can use G84/G88 with M29 or just G84.2
        if met_tool$, pitch = n_tap_thds$  # Tap pitch (mm  per thread)
        else, pitch = 1/n_tap_thds$       # Tap pitch (inches per thread)
        pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
          prdrlout, dwell$, *pitch, !feed, strcantext, e$
        ]
      pcom_movea
      pcanceldcl

lbore1$          #Canned bore #1 cycle, lathe
      ldrill$

lbore2$          #Canned bore #2 cycle, lathe
      ldrill$

lmisc1$          #Bar Stop
     pdrlcommonb
    mx = vequ(refht_x)
     gcode$ = 0
    n$, *sgcode, ~mx, [if y_axis_mch, ~my], ~mz, e$
    mz = depth_z
    n$, mz, e$
    n$, 47, no_spc$, *sclmp_main, e$
    n$, "G4 P850", e$
    n$, 47, no_spc$, *sunclmp_main, e$
    n$, "G4 P750", e$
    mz = refht$
    n$, mz, e$
    mz = initht$
    n$, ~mz, e$
     pcom_movea

lmisc2$          #Canned misc #2 cycle, lathe
      ldrill$

mdrill$          #Canned drill cycle, mill
      pdrlcommonb
      n$,  pcout, pindexdrl, e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
      prdrlout, dwell$, pffr, pfclampon, strcantext, e$
      pcom_movea

mpeck$         #Canned peck drill cycle, mill
      pdrlcommonb
      n$, pcout, pindexdrl, e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, peck1$, dwell$, pffr, pfclampon, strcantext, e$
      pcom_movea

mchpbrk$       #Canned chip break cycle, mill
      pdrlcommonb
      n$,  pcout, pindexdrl, e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, *peck1$, dwell$, pffr, pfclampon, strcantext, e$
      pcom_movea

mtap$          #Canned tap cycle, mill
      pdrlcommonb
      if use_pitch = 0, #Feed/Min mode, feed divided by spindle speed is equal to thread lead 
        [
        if rigid_tap, pbld, n$, *sm29, *speed, e$           #Rigid Tapping    Can use G84/G88 with M29 or just G84.2
        n$,  pcout,  pindexdrl, e$
        pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
         prdrlout, dwell$, pffr, pfclampon, strcantext, e$
          #pindexdrl, prdrlout, dwell$, pffr, [if rigid_tap, "P500"], pfclampon, strcantext, e$          
        ]
      else, #Feed/Rev mode, feed is equal to thread lead 
        [
        if rigid_tap, pbld, n$, *sm29, *speed, e$           #Rigid Tapping    Can use G84/G88 with M29 or just G84.2
        if metvals, pitch = n_tap_thds$  # Tap pitch (mm  per thread)
        else, pitch = 1/n_tap_thds$       # Tap pitch (inches per thread)
        n$,  pcout,  pindexdrl, e$
        pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, dwell$, *pitch, !feed, pfclampon, strcantext, e$
          #pindexdrl, prdrlout, dwell$, *pitch, !feed, [if rigid_tap, "P500"], pfclampon, strcantext, e$
        ]
      pcom_movea

mbore1$        #Canned bore #1 cycle, mill
      mdrill$

mbore2$        #Canned bore #2 cycle, mill
      mdrill$

mmisc1$        #Canned misc #1 cycle, mill
      pdrlcommonb
      n$,  pcout, pindexdrl, e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        prdrlout, *shftdrl$, dwell$, pffr, pfclampon, strcantext, e$
      pcom_movea

mmisc2$        #Canned misc #2 cycle, mill
      mdrill$

mdrill_2$      #Canned drill cycle repeat, mill
      pdrlcommonb
      n$, pcout, pindexdrl, e$
      if mdrl_dir, result = force(zabs, zabs)
      else, result = force (xabs, xabs)
      pcan1, pbld, n$, pxout, pyout, pzout,  prdrlout,
      [if peck1$, *peck1$], dwell$, pfr, strcantext, e$
      pcom_movea

mpeck_2$       #Canned peck drill cycle repeat, mill
      mdrill_2$

mchpbrk_2$     #Canned chip break cycle repeat, mill
      pdrlcommonb
      if mdrl_dir, result = force(zabs, zabs)
      else, result = force (xabs, xabs)
      n$,  pcout, pindexdrl,  e$
      pcan1, pbld, n$, pxout, pyout, pzout, prdrlout,
      [if peck1$, *peck1$], dwell$, pfr, strcantext, e$
      pcom_movea

mtap_2$        #Canned tap cycle repeat, mill
      pdrlcommonb
      n$, pcout, pindexdrl, e$
      if mdrl_dir, result = force(zabs, zabs)
      else, result = force (xabs, xabs)
      pcan1, pbld, n$, pxout, pyout, pzout, prdrlout,  dwell$, strcantext, e$
      pcom_movea

mbore1_2$      #Canned bore #1 cycle repeat, mill
      mdrill_2$

mbore2_2$      #Canned bore #2 cycle repeat, mill
      mdrill_2$

mmisc1_2$      #Canned misc #1 cycle repeat, mill
      mdrill_2$

mmisc2_2$      #Canned misc #2 cycle repeat, mill
      mdrill_2$

pdrlcst$         #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, pfcout, pindexdrl, e$
      pcom_movea

pdrlcst_2$       #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, pfcout, pindexdrl, e$
      pcom_movea

pcanceldc$     #Cancel mill drill cycle
      xabs = vequ (initht_x) #Position to return
      ps_inc_calc
      pe_inc_calc #Update to current location
      gcode$ = zero
      pcan
      pcan1, pbld, n$, sgcode, "G80", strcantext, e$
      pcan2

pcanceldcl     #Cancel lathe drill cycle
      xabs = vequ (initht_x) #Position to return
      ps_inc_calc
      pe_inc_calc #Update to current location
      gcode$ = zero
      pcan
      pcan1, pbld, n$, sgcode, "G80", strcantext, e$
      pcan2

# --------------------------------------------------------------------------
# Version 9+ MiscOps Section  
# --------------------------------------------------------------------------
#Miscellaneous Variables Common to all Miscops operations 
#Format as needed

#Integers
#miscops_mi1, miscops_mi2, miscops_mi3, 
#miscops_mi4,  miscops_mi5, miscops_mi6, 
#miscops_mi7, miscops_mi8, miscops_mi9, 
#miscops_mi10 

#Reals
#miscops_mr1, miscops_mr2, miscops_mr3, 
#miscops_mr4, miscops_mr5, miscops_mr6, 
#miscops_mr7, miscops_mr8, miscops_mr9, 
#miscops_mr10
#
# --------------------------------------------------------------------------
#Format Assignments and Initializations
# --------------------------------------------------------------------------
fmt "Z" 2 stck_init_z$           #Initial Z position of the stock (900-902,904,905)
fmt "Z" 2 stck_final_z$          #Final Z position of the stock (900-902,904,905)
fmt "Z" 2 stck_chuk_st_z$        #Initial Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_st_x$        #Initial X axis Chuck Position (900-903)
fmt "Z" 2 stck_chuk_end_z$       #Final Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_end_x$       #Final X axis Chuck Position (900-903)
fmt "B" 3 stck_chuk_st_dz$       #Destination chuck Z axis reference position before transfer (900)
fmt "U" 3 stck_chuk_st_dx$       #Destination chuck X axis reference position before transfer (900)
fmt "B" 3 stck_chuk_end_dz$      #Destination chuck Z axis reference position after transfer (900)
fmt "U" 3 stck_chuk_end_dx$      #Destination chuck X axis reference position after transfer (900)
fmt "Z" 2 stck_clear$            #Stock clearance value for stock pull operation (902)
fmt "X" 2 stck_tool_x$           #Tool X axis position for bar stop / puller (902)
fmt "Z" 2 stck_grip$             #Grip length value for stock pull operation(902)

fmt "F" 18 stck_adv_fr$          #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)
fmt "F" 18 stck_appr_fr$         #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)

#Flags
stck_op$         : 0             #Stock advance operation method (902)
                                #(0=Push stock,1=Push stock with Use Tool Stop option,2=Pull stock)
stck_spindle$    : 0             #Active spindle with stock to transfer (900-902)
                                #0=Left Spindle,1=Right Spindle
clmp_op$         : 0             #The selected Operation mode: 0=Clamp,1=Un-clamp,2=Re-position (903)
clmp_spindle$    : 0             #Active spindle for clamp/unclamp 0=Left Spindle,1=Right Spindle (903)
tlstck_on$       : 0             #Retract or engage the tailstock (0=Retract,1=Engage) (904)

toolend_flg     : 1             #Flag to execute ptoolend sequence or not
transfer        : 0

fmt "T" 4 miscops_mi1$      #Tool call
fmt "B" 2 miscops_mr1$      #sub rapid point
fmt "B" 2 miscops_mr2$      #sub feed point
fmt "Z" 2 miscops_mr3$      #tool move point 


fmt "B" 2 subreturn         #Initial Z axis Chuck Position (900-903)
# --------------------------------------------------------------------------
#Postblock Section -comments only!
# --------------------------------------------------------------------------
pstck_trans$     #NCI code = 900 available variables:
                #stck_spindle, stck_init_z, stck_final_z, 
                #stck_chuk_st_z, stck_chuk_st_x, 
                #stck_chuk_end_z, stck_chuk_end_x, 
                #stck_chuk_st_dz, stck_chuk_st_dx, 
                #stck_chuk_end_dz, stck_chuk_end_dx
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
#                 !spaces$
#                 spaces$ = zero
#                 pbld, n$, "M00",e$
#                 if prv_spaces$ > 0, " ",e$
#                 if stck_spindle$ = 0, "(Xfer Part from Left Spindle)", e$
#                 if stck_spindle$ = 1, "(Xfer Part from Right Spindle)", e$
#                 spaces$ = prv_spaces$
                ]

      !spaces$
      spaces$ = zero

      *e$
      if stck_chuk_st_dz$ = stck_chuk_end_dz$,
       [
       pbld, n$, "(CHUCK RETRACT ONLY)", e$
       transfer = 2
       ]
      else,
       [
       pbld, n$, "(TRANSFER)", e$                #Transfer program
       transfer = 1
       ]

      if transfer = 1,
        [
        toolchng = 1
        pbld, n$, pwcs, e$
        toolchng = 0

        if miscops_mi1$,    #No output of tool or motion if no tool selected
          [
          toolno = miscops_mi1$
          if omitseq$ = 1 & tseqno > 0,
            [
            if tseqno = 2, n$ = int(miscops_mi1$ / 100)
            pbld, *n$, *toolno, "(CUTOFF TOOL, MISC INT 1)", e$
            ]
          else, pbld, n$, *toolno, "(CUTOFF TOOL, MISC INT 1)", e$
          pbld, n$, "G0", *miscops_mr3$, "(TOOL RAPID POSITION, MISC REAL 3)", e$  #MOVE TO POSITION
          ]


        pbld, n$, "(OPEN SUB HERE)", e$

        pbld, n$, "G0", *miscops_mr1$, "(SUB RAPID POSITION, MISC REAL 1)", e$           #sub rapid to position

        if miscops_mi2$,
          [
          pbld, n$, "G1G98", *miscops_mr2$, "(SUB FEED POSITION, MISC REAL 2)", "F50.", e$     #sub feed to position              
          pbld, n$, "(TORQUE SKIP MODE ON HERE)", e$    #torque skip
          pbld, n$, "(TORQUE SKIP CODE HERE)G98", *stck_chuk_end_dz$, "F30.", "(SUB PICK-OFF POSITION)", e$     #sub feed to position      
          #Usually there's a macro here to check if it's within tolerance of the theoretical position    
          ]
        else, pbld, n$, "G1G98", *stck_chuk_end_dz$, "F50.", "(SUB PICK-OFF POSITION)", e$


        pbld, n$, "G4", "U500", e$           #dwell
        pbld, n$, "(CLOSE SUB HERE)", e$              #close sub
        pbld, n$, "G4", "U500", e$            #dwell

        if stck_init_z$ <> stck_final_z$,
          [
          #output this little section if you want motion before the cutoff
          pbld, n$, "(OPEN MAIN HERE)", e$
          pbld, n$, "G4U500", e$  #
          subreturn = (stck_final_z$ - stck_init_z$) + stck_chuk_end_dz$
          pbld, n$, "G1G98", *subreturn, "F50.", "(SUB RETRACT POSITION)", e$  #This could be a G28 or a # macro variable also
          pbld, n$, "(CLOSE MAIN HERE)", e$  #(MAINCLOSE) 
          pbld, n$, "G4U500", e$  #
         ]
       ]


           #Cutoff code goes here


      if transfer = 2,
        [
        pbld, n$, "G55", "G0", "B0.", "(SETUP SUB RETURN HOME)", e$    #Assuming G55 and B0 is set at home, this could be a G28 or a # macro variable
        pbld, n$, "M01", e$
        *e$
        ]

      spaces$ = prv_spaces$


pstck_flip$      #NCI code = 901 available variables:
                #stck_spindle, stck_init_z, stck_final_z, 
                #stck_chuk_st_z, stck_chuk_st_x, 
                #stck_chuk_end_z, stck_chuk_end_x
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
                 !spaces$
                 spaces$ = zero
                 pbld, n$, "M00",e$
                 if prv_spaces$ > 0, " ",e$
                 "(Flip Stock)", e$
                 spaces$ = prv_spaces$
                ]

pstck_bar_fd$    #NCI code = 902 available variables:
                #stck_spindle, stck_op, stck_clear, 
                #stck_grip, stck_init_z, stck_final_z, 
                #stck_chuk_st_z, stck_chuk_st_x, 
                #stck_chuk_end_z, stck_chuk_end_x,
                #stck_adv_fr, stck_appr_fr
                if stck_op$ <> 1,  # if NOT using the 'Tool Stop option'
                 [
                  if toolchng <> two, ptoolend$
                  toolend_flg = zero  #Do not execute ptoolend again after xfer
                 ]
                else,
                 toolend_flg = one  #DO execute ptoolend after xfer

                [
                  #!spaces$
                  #spaces$ = zero
                  pbld, n$, "G04 P1.", e$
                  pbld, n$, "M00",e$
                  if prv_spaces$ > 0, " ",e$
                  if stck_op$ = 0, "(Push stock -"
                  if stck_op$ = 1, "(Push stock with Use Tool Stop option -"
                  if stck_op$ = 2, "(Pull stock -"
                  if stck_spindle$ = 0, " from Left Spindle)", e$
                  if stck_spindle$ = 1, " from Right Spindle)", e$
                  #spaces$ = prv_spaces$
                ]

pchuck$          #NCI code = 903 available variables:
                #clmp_spindle, clmp_op,  stck_chuk_st_z, 
                #stck_chuk_st_x, stck_chuk_end_z, stck_chuk_end_x
                if clmp_op$ = two,
                  [
                  if toolchng <> two, ptoolend$
                  toolend_flg = zero  #Do not execute ptoolend again after xfer
                  ]

                [
                  !spaces$
                  spaces$ = zero
                  pbld, n$, "M00",e$
                  if prv_spaces$ > 0, " ",e$
                  if clmp_op$ = 0, "(Clamp -",e$
                  if clmp_op$ = 1, "(Un-clamp -",e$
                  if clmp_op$ = 2, "(Re-position -",e$
                  if clmp_spindle$ = 0, " Left Spindle)", e$
                  if clmp_spindle$ = 1, " Right Spindle)", e$
                  spaces$ = prv_spaces$
                ]
                if clmp_op$ >= one, pchuck_unclamp
                if clmp_op$ = two, pbld, n$, *stck_chuk_end_z$, e$
                if clmp_op$ = zero | clmp_op$ = two, pchuck_clamp

pchuck_clamp    #user-defined postblock for chuck clamp 
                if clmp_spindle$ = zero, sclmp_main, e$
                if clmp_spindle$ = one, sclmp_sub, e$

pchuck_unclamp  #user-defined postblock for chuck unclamp                 
                if clmp_spindle$ = zero, sunclmp_main, e$
                if clmp_spindle$ = one, sunclmp_sub, e$

ptailstock$      #NCI code = 904 available variables:
                #tlstck_on, stck_init_z, stck_final_z
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
                 !spaces$
                 spaces$ = zero
                 pbld, n$, "M00",e$
                 if prv_spaces$ > 0, " ",e$
                 if tlstck_on$ = 0, pbld, *sm26, "(Retract Tailstock)", e$
                 if tlstck_on$ = 1, pbld, *sm25, "(Engage Tailstock)", e$
                 spaces$ = prv_spaces$
                ]

psteadyrest$     #NCI code = 905 available variables:
                #stck_init_z, stck_final_z
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
                 !spaces$
                 spaces$ = zero
                 pbld, n$, "M00",e$
                 if prv_spaces$ > 0, " ",e$
                 "(Position Steadyrest)", e$
                 spaces$ = prv_spaces$
                ]

# --------------------------------------------------------------------------
# Threading output
# --------------------------------------------------------------------------
pthread0$        #Pre-thread calculations
      # Calculate taper delta 'X' on Acceleration Clearance distance
      thdrdlt = (((thdx2$ - thdx3$) / (thdz1$ - thdz2$)) * thdzclr$)
      # Add to the original thread 'X' difference calculation
      thdrdlt = (thdrdlt + (thdx2$ - thdx3$)) * pl_ax_m0x
      #thdang = rad2deg$ * thdangle$      #lead-in angle
      #thdang = rad2deg$ * thda1$       #half of the thread angle
      thdang = rad2deg$ * thda2$        #thread angle (full included angle)
      thd_dirx = (thdx2$ - thdx3$) * pl_ax_m0x
      thd_dirz = (thdz1$ - thdz2$) * pl_ax_m0z
      thd_vlen = thdlead$/ nstarts$
      thd_dirx = vsa (thd_vlen, thd_dirx)
      if fr_pos$, pthreadpull
      else, thdpull = zero

pthreadpull     #Pre-thread calculations
      if thdpulloff$/(fr_pos$*10) > 0.99,thdpull = 99
      else, thdpull = (thdpulloff$/(fr_pos$*10))*100

pthdext$         #Calculation override for external thread
      #thddepth = thdlead * .61343         #Calc. thread depth
      #thdflat  = thdlead * .1667          #Calc. thread flat

pthdint$         #Calculation override for internal thread
      #thddepth = thdlead * .54127         #Calc. thread depth
      #thdflat  = thdlead * .125           #Calc. thread flat

pthdface$        #Calculation override for face thread
      #thddepth = thdlead * .61343         #Calc. thread depth
      #thdflat  = thdlead * .1667          #Calc. thread flat

pthrg32_1$       #G32 threading first
      comment$
      gcode$ = zero
      lrapid$

pthrg32_2$       #G32 threading second
      gcode$ = zero
      lrapid$

pthrg32_3$       #G32 threading third
      copy_x = vequ(x$)
      pcom_moveb
      pcan1, pbld, n$, psgfeed, *sthdgcode, pxout, pyout, pzout, pcout, pffr,
      strcantext, e$
      pcom_movea
      prv_gcode$ = m_one

pthrg32_4$       #G32 threading fourth
      gcode$ = zero
      lrapid$

pthrg92_1$       #G92 threading
      if thdpass$ = one, pthrg92_11

pthrg92_11      #G92 threading
      comment$
      gcode$ = zero
      lrapid$
      prv_feed = m_one
      prv_zabs = c9k
      prv_thdtype$ = m_one

pthrg92_2$       #G92 threading

pthrg92_3$       #G92 threading
      copy_x = vequ (x$)
      pcom_moveb
      pcan1, pbld, n$, psgfeed, sthdgcode, pfxout, pyout, pzout, pcout,
        [if thdrdlt & thdpass$ = one, *thdrdlt], pfr, strcantext, e$
      pcom_movea
      prv_gcode$ = m_one

pthrg92_4$       #G92 threading

pg32e$           #G32/G92 threading end
      gcode$ = zero
      lrapid$

pthrg76_1$       #G76 threading start point
      gcode$ = zero
      lrapid$

pg76$            #G76 threading
      comment$
      gcode$ = zero
      lrapid$
      sav_xa = vequ(copy_x)
      if thdface$ = zero, copy_x = thdx2$
      else, copy_z = thdx2$
      if thdface$ = zero, copy_z = thdz2$
      else, copy_x = thdz2$
      pcom_moveb
      nstart_cnt = zero
      while nstart_cnt < nstarts$, pg76nstart
      pcom_movea
      prv_gcode$ =  -1
      copy_x = vequ(sav_xa)
      copy_x = copy_x + (thd_dirx * (nstarts$ - one))
      copy_z = copy_z + (thd_dirz * (nstarts$ - one))
      pcom_moveb
      pe_inc_calc
      !gcode$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc

pg76nstart      #G76 threading, for multiple starts
      if old_new_sw = zero, pg76old
      else, pg76new
      nstart_cnt = nstart_cnt + one
      if nstarts$ <> one & nstart_cnt <> nstarts$,
      pbld, n$, *sgcode, thd_dirx, thd_dirz, e$

pg76old         #G76 threading old style
      pbld, n$, *sthdgcode, pfxout, pfzout, *thdrdlt, *thddepth$,
        *thdfirst$, *thdang, pffr, e$

pg76new         #G76 threading new style
      pbld, n$, *sthdgcode, *nspring$, *thdpull, *thdang, *thdlast$,
        *thdfinish$, e$
      pbld, n$, *sthdgcode, pfxout, pfzout, *thddepth$, *thdfirst$,
        *thdrdlt, pffr, e$

# --------------------------------------------------------------------------
# Lathe canned cycle output
# --------------------------------------------------------------------------
pg71old         #Output G71-G72 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc,
        *depthcc, pffr, e$

pg71new         #Output G71-G72 canned cycle routines, new style, first
      if gcodecc = 1, result = nwadrs (stru, depthcc)
      else, result = nwadrs (strw, depthcc)
      pbld, n$, *scclgcode, *depthcc, *clearcc, e$
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc, pffr, e$

pg73old         #Output G73 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, *ng70e, *g73x, *g73z,
        *xstckcc, *zstckcc, *ncutscc, pffr, e$

pg73new       #Output G73 canned cycle routines, new style, first
      pbld, n$, *scclgcode, *g73x, *g73z, *ncutscc, e$
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc, pffr, e$

pg74old         #Output G74-G75 canned cycle routines, old style
      pbld, n$, *scclgcode, pfxout, pfzout, *grvspcc, *grvdpcc,
        *clearcc, pffr, e$

pg74new         #Output G74-G75 canned cycle routines, new style, first
      pbld, n$, *scclgcode, *clearcc, e$
      pbld, n$, pfsgfeed, *scclgcode, pfxout, pfzout, *grvspcc,
        *grvdpcc, pffr, e$

prcc_setup$      #Lathe canned cycle setup
                #Capture values from rough
      sav_iprcc = c1_ipr_actv
      sav_feedcc = c1_fr_pos
      if orient$ = one|orient$ = two|orient$ = five|orient$ = 6, lccdirx = one
      else, lccdirx = m_one
      if orient$ = one|orient$ = four|orient$ = five|orient$ = 8, lccdirz = one
      else, lccdirz = m_one
      if lathecc > zero, cc_stop_fcc = one
      else, cc_stop_fcc = zero
      #G74/G75
      if lathecc = three,
        [
        lcc_xcst = vequ (copy_x)
        if dopeckcc = zero,
          [
          depthcc = zero
          clearcc = zero
          ]
        if directcc > one,
          [
          gcodecc = four
          grvspcc = stepcc
          grvdpcc = depthcc
          ]
        else,
          [
          gcodecc = five
          grvspcc = depthcc
          grvdpcc = stepcc
          ]
        ]
      else,
        [
        if n1_cc_pos,
          [
          sav_xa = vequ(copy_x)
          #Shift for cutter comp. start position
          copy_x = copy_x + (lcc_move * lccdirx)
          copy_z = copy_z + (lcc_move * lccdirz)
          pcom_moveb
          compok = zero
          lcc_cc_pos = one
          ]
        else, lcc_cc_pos = zero
        ]
      if org_x_pos & tool_op$ = 202 | tool_op$ = 203,     #CRF
        [
        crf_xsav1 = x$
        crf_zsav1 = z$
        ]

prcc_call_st$    #Rough canned cycle start
      if tool_op$ <> 208,
        [
        sav_subout = subout$
        sav_omitsq = omitseq$
        omitseq$ = one
        extprg$ = one
        subout$ = three
        prv_gcode$ = m_one #Added (06/25/01)
        ]

prcc_call_end$   #Rough canned cycle end
      # Restore cc_1013 to the value it held prior to the rough  # 1/17/03
      # groove canned cycle. cc_1013 was changed in ptoolend.    # 1/17/03
      if tool_op$ = 208 | tool_op$ = 62, cc_1013$ = sav_cc_1013     # 1/17/03

      if tool_op$ <> 208,
        [
        omitseq$ = sav_omitsq
        #Close the ext file
        result = fclose (sbufname3$)
        #Open the ext file as a buffer
        #Use the size to determine the start and end sequence
        subout$ = sav_subout
        size3 = rbuf(three, zero)
        if omitseq$ = one,
          [
          ng70s = n$
          ng70e = n$ + seqinc$
          ]
        else,
          [
          if old_new_sw = zero, ng70s = n$ + seqinc$
          else, ng70s = n$ + (seqinc$ * two)
          ng70e = ng70s + (seqinc$ * (size3 - one))
          ]
        pwrite_g70
        ]
      #Setup the stock and clearance directions
      g73x = vsub (lcc_xcst,lcc_xcend)
      if old_new_sw = zero, g73x = g73x * pl_ax_m0x
      else, g73x = g73x * dia_mult
      g73z = g73z * pl_ax_m0z
      xstckcc =  xstckcc * dia_mult * lccdirx
      zstckcc =  zstckcc * lccdirz * pl_ax_m0z
      clearcc =  clearcc * lccdirz * pl_ax_m0z
      #Write the cycle definition
      sav_feed = feed
      sav_ipr = ipr_actv$
      feed = sav_feedcc
      ipr_actv$ = sav_iprcc
      if lathecc = three,
        [
        #Setup the previous position for inc. in G74/G75 cycle
        sav_xa = vequ(xabs) #Save the cycle end
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Recalculate incremental
        pe_inc_calc #Update previous at start
        xabs = vequ(sav_xa) #Restore the cycle end
        ps_inc_calc #Recalculate incremental
        ]
      if old_new_sw = zero,
        [
        if gcodecc < three, pg71old
        if gcodecc = three, pg73old
        if gcodecc > three, pg74old
        ]
      else,
        [
        if gcodecc < three, pg71new
        if gcodecc = three, pg73new
        if gcodecc > three, pg74new
        ]
      if lathecc = three,
        [
        #Set the cycle end position at the original start
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Position at start
        pe_inc_calc #Update previous
        ps_inc_calc #Recalculate incremental
        ]
      feed = sav_feed
      ipr_actv$ = sav_ipr
      if tool_op$ <> 208,
        [
        #Bug2 is off to prevent execution crashes with long strings
        bug2$ = zero
        #Write the cycle profile, sequence are written now
        rc3 = one
        while rc3 <= size3,
          [
          sav_eob = eob$           #save out eob character as it's getting lost
          eob$ = 32                #save out eob character as it's getting lost
          prv_eob$ = 32            #save out eob character as it's getting lost   
          #Write the lathe canned cycle profile
          string3 = rbuf (three, rc3)
          if rc3 = two,
            [
            #Add the finish spindle speed to the first move
            speed = n1_ss
            #Mastercam is reporting 0 and 2 backwards for parameter 10124
            #Note that G71 type 1 and 3 are never allowed (can't change Z dir)
            if g71type = 2 | g71type = 3, pbld, *n$, *string3, *speed, e$
            if g71type = 1 | g71type = 0, pbld, *n$, *string3, *speed, "W0.", e$
            ]
          else,
            [
            if omitseq$ = one & rc3 = size3 + one, pbld, *n$, *string3, e$
            else, pbld, n$, *string3, e$
            ]
          eob$ = sav_eob          #save out eob character as it's getting lost     
          ]
        #Close the buffer
        result = fclose (three)
        #Remove the ext file
        result = remove (sbufname3$)
        bug2$ = sav_bug2
        ]

pfcc_call$       #G70 recall output postblock
      if cc_stop_fcc = zero,
        [
        pread_g70
        if foundcc = zero, result = mprint(sfccerror)
        ]
      no_nc_out$ = zero
      cc_stop_fcc = zero

pread_g70       #Read G70 recall buffer
      foundcc = zero
      size2 = rbuf (two, zero)
      wc2 = one
      while wc2 <= size2 & foundcc = zero,
        [
        fcc_subid = rbuf (two, wc2)
        if fcc_subid = sub_op_id$,
          [
          gcodecc = zero
          ng70s = fcc_ng70s
          ng70e = fcc_ng70e
          pbld, n$, *scclgcode, *ng70s, *ng70e, e$
          foundcc = one
          ]
        ]

pwrite_g70      #Write G70 recall buffer
      fcc_subid = sub_op_id$
      fcc_ng70s = ng70s
      fcc_ng70e = ng70e
      fcc_subid = wbuf (two, rc2)
      if org_x_pos & tool_op$ = 202 | tool_op$ = 203,     #CRF
        [
        #Set the crf_flg to indicate that it's a canned rough and finish
        #Must be set after the output of the N (indicator of the end of the shape) so we can replace the Z coordinate at the right time.  
        crf_line = sub_op_id$
        crf_xsav1 = wbuf(4,crf_line)
        prv_xabs = c9k
        ]

# --------------------------------------------------------------------------
#Subprogram output
#sub_trnstyp - 0=mirror, 1=rotate, 2=scale, 3=translate
#sub_trnmthd (mirror) - 0=X axis, 1=Y axis, 2=line
#sub_trnmthd (rotate) - 0=tplane, 1=tplane origin only, 2=coordinates
# --------------------------------------------------------------------------
pmiscint$        #Capture the top level absinc for subprograms
      if sub_level$ <= zero, absinc$ = hard_mi2
      ref_ret = hard_mi3
      synch_flg = mi5$

psub_call_m$     #Call to main level, single tool
      psub_call_trans

psub_call_mm$    #Call to main level, multiple tools
      psub_call_trans

psub_call_trans #Translate level calls from toolchange, user
      #Mirror and coordinate rotate subs not allowed with lathe
      if sub_trnstyp$ <> three & posttype$ = two, result = mprint(slthrmerror)
      if (sub_trnstyp$ = one & sub_trnmthd$ = two)
      | sub_trnstyp$ = zero, result = mprint(smilrmerror)
      sav_absinc = absinc$
      pindex
      if home_type > one,
        [
        if sub_mny_t$,
          [
          absinc$ = zero
          pbld, n$, pwcs, e$
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, pfcout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      else,
        [
        if home_type = one, result = mprint(shomeserror)
        else,
          [
          if sub_mny_t$, result = mprint(smny50error)
          ]
        #Apply G50 shift and correct incremental position
        if sub_sec_no$ & sub_trnstyp$ = three,
          [
          sub_trnsx$ = vmap(sub_trnsx$, hmtx1)
          sub_trnsx$ = vscl(m_one, sub_trnsx$)
          sub_trnsx$ = sub_trnsx$ * dia_mult
          sub_trnsy$ = sub_trnsy$ * y_mult
          sub_trnsz$ = sub_trnsz$ * z_mult
          pbld, n$, *sg50, *sub_trnsx$, [if y_axis_mch, *sub_trnsy$],
            *sub_trnsz$, e$
          prv_xia = vadd(prv_xia, sub_trnsx$)
          ps_inc_calc
          ]
        if toolchng = zero | home_type < two,
          [
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, pfcout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      absinc$ = sav_absinc
      result = nwadrs(strp, main_prg_no$)
      pbld, n$, "M98", *main_prg_no$, e$
      result = force(feed,feed) #Force feed in sub

psub_st_m$       #Header in main level
      result = nwadrs(stro, main_prg_no$)
      " ", e$
      *main_prg_no$, e$

psub_end_m$      #End in main level
      n$, "M99", e$

psub_call_s$     #Call to sub level
      if tool_op$ = 201,  pread_g70
      else, foundcc = zero

      if foundcc = zero,
        [
        result = nwadrs(strp, sub_prg_no$)
        sub_prg_no$ = sub_prg_no$ + 1000 #Add sub number offset
        pbld, n$, "M98", *sub_prg_no$, e$
        ]

psub_st_s$       #Header in sub leveln
      result = nwadrs(stro, sub_prg_no$)
      " ", e$
      *sub_prg_no$, e$

psub_end_s$      #End in sub level
      n$, "M99", e$

pbar_feed       #Bar stop  #5/29/08
            zabs = stck_clear$
        n$, *sgcode, pfxout, pyout, *sunclmp_main, e$
            n$, pfzout, e$
            n$, "G04 P3.", e$
        n$, *sclmp_main, e$
            zabs = stck_final_z$, e$
        n$, pfzout, e$
         !xabs, !zabs

psp_select  #Spindle Select  #5/29/08
        if spindle_no$, n$, *sp_selmn, e$
        else, n$, *sp_selsb, e$

# --------------------------------------------------------------------------
# Canned Text
# --------------------------------------------------------------------------
pcan            #Canned text - before output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1           #Canned text - with move
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = one | cant_pos1$ = four, pcant_1
        if cant_pos2$ = one | cant_pos2$ = four, pcant_2
        if cant_pos3$ = one | cant_pos3$ = four, pcant_3
        if cant_pos4$ = one | cant_pos4$ = four, pcant_4
        if cant_pos5$ = one | cant_pos5$ = four, pcant_5
        if cant_pos6$ = one | cant_pos6$ = four, pcant_6
        if cant_pos7$ = one | cant_pos7$ = four, pcant_7
        if cant_pos8$ = one | cant_pos8$ = four, pcant_8
        if cant_pos9$ = one | cant_pos9$ = four, pcant_9
        if cant_pos10$ = one | cant_pos10$ = four, pcant_10
        if cant_pos11$ = one | cant_pos11$ = four, pcant_11
        if cant_pos12$ = one | cant_pos12$ = four, pcant_12
        if cant_pos13$ = one | cant_pos13$ = four, pcant_13
        if cant_pos14$ = one | cant_pos14$ = four, pcant_14
        if cant_pos15$ = one | cant_pos15$ = four, pcant_15
        if cant_pos16$ = one | cant_pos16$ = four, pcant_16
        if cant_pos17$ = one | cant_pos17$ = four, pcant_17
        if cant_pos18$ = one | cant_pos18$ = four, pcant_18
        if cant_pos19$ = one | cant_pos19$ = four, pcant_19
        if cant_pos20$ = one | cant_pos20$ = four, pcant_20
        ]
      if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line 

pcan2           #Canned text - after output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1         #Canned text - output call
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Canned text - output call
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Canned text - output call
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Canned text - output call
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Canned text - output call
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Canned text - output call
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Canned text - output call
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Canned text - output call
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Canned text - output call
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Canned text - output call
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Canned text - output call
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Canned text - output call
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Canned text - output call
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Canned text - output call
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Canned text - output call
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Canned text - output call
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Canned text - output call
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Canned text - output call
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Canned text - output call
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Canned text - output call
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
      #Assign string select type outputs
      if cant_pos < three, #cant_pos indicates canned text output
        [
        #Assign string select global variables
        if cantext$ = 3, bld = one
        if cantext$ = 4, bld = zero
        if cantext$ = 9, exact = one
        if cantext$ = 10, exact = zero
        #Build the cantext string from strings
        if cantext$ = 1, strcantext = strcantext + sm00
        if cantext$ = 2, strcantext = strcantext + sm01
        #Build the cantext string from string selects
        if cantext$ = 5 | cantext$ = 6,
          [
          if cantext$ = 5, tlstk = zero
          else, tlstk = one
          rslt_upd = updstr (stlstk)
          strcantext = strcantext + stlstk
          ]
        if cantext$ = 7 | cantext$ = 8,
          [
          if cantext$ = 7, chute = zero
          else, chute = one
          rslt_upd = updstr (schute)
          strcantext = strcantext + schute
          ]
        #Build the cantext string from cantext number
        if cantext$ > 10,
          [
          strtextno = no2str(cantext$)
          strcantext = strcantext + strm + strtextno
          ]
        ]
      else, #cant_pos indicates coolant output
        [
        coolant_bin = flook (two, cantext$) #Create binary value for each coolant using lookup table
        if frac(cantext$/two),
          [
          if all_cool_off,
            [
            if coolant_on, pbld, n$, *sall_cool_off, e$
            coolant_on = zero
            suppress = 1               #WBT added this for null toolchange with "First command shuts all off" 
                                       #and turn off selected in the second op, post outputs M9 twice
            ]
          else, coolant_on = coolant_on - coolant_bin/2 #Odd = off command, subtract appropriate binary value.
          ]
        else,                                         #Even = on command
          [   #Determine if this coolant is already on
          local_int = zero
          coolantx = zero
          while local_int < 20,
            [
            result2 = and(2^local_int, coolant_on)
            local_int = local_int + one
            if result2 = coolant_bin, suppress = one
            ]
          ]
        if suppress <> 1, #Don't output an on code for a coolant that is already on
          [
          if not(frac(cantext$/two)), coolant_on = coolant_on + coolant_bin #Maintain binary sum of all coolants currently on
          coolantx = cantext$ - 50                                          #Create a coolantx value for string select
          pbld, n$, *scoolantx, e$
          ]
        suppress = zero
        ]

pheader$         #Start of file
      pheader_custom
      if tseqno = 1 & omitseq$ = 1,
        [
        seqno$ = 1
        seqinc$ = 1
        n$ = seqno$
        ]

# --------------------------------------------------------------------------
# Position calculations, generally these do not need to be modified
# --------------------------------------------------------------------------
#The variables for absolute output are xabs, yabs, zabs.
#The variables for incremental output are xinc, yinc, zinc.
#They are found from the input variables x, y, z (typically) which are
#copied to copy_x, copy_y, copy_z.  These are passed to the mapping routine
#to get raw machine coordinates xa, ya, za.  These are used in pxyxcout to
#get the output xabs, yabs, zabs.  ps_inc_calc is called to get xinc, yinc,
#zinc.  cfeed_x, cfeed_y, cfeed_z are the unshifted positions for feed
#calculations.
# --------------------------------------------------------------------------
pxyzcout      #Perform calls for mapping coordinates and shifts
      if posttype$ <> two & y_axis = zero & millcc = zero & fmtrnd(xca) = zero & fmtrnd(yca) = zero & mach_plane = zero, czero_csav = prv_csav
      pplane_mod
      if cuttype = one, pxyzcout0                   #Turning
      if abs(cuttype) = two                         #Right/Left Face cut
      | abs(cuttype) = three, pxyzcout2             #Cross cut
      if cuttype = four, pxyzcout4                  #Y axis substitution
      if cuttype = five, pxyzcout5                  #Multisurf Rotary
      #C axis control modifications
      if posttype$ <> two,
        [
        pcoutrev
        if rot_dir, cabs = c_wnd * m_one
        else, cabs = c_wnd
        if c_axistype > one | millcc,
          [
          pindxcalc
          if c_axistype = three,
            [
            #Check if in tolerance
            cdelta = frac(abs(cabs)/ctable)
            if cdelta > ixtol & cdelta < 1-ixtol,
              [
              result = mprint(sindxerror)
              exitpost$
              ]
            indx_out = cabs
            ]
          if c_axistype = two, #Signed direction calculation
            [
            #Warn if a move greater than 360
            if abs(prvc_wnd - c_wnd) > 360, result = mprint(ssignerror)
            ]
          ]
        if y_axis = zero,
          [
          if cir_at_zero = one, gcode$ = one #only C is moving
          if cir_at_zero = m_one & (xa < zero | prv_xa < zero), c_ax_flp = one
          else, c_ax_flp = zero
          ]
        if millcc,
          [
          if fmtrnd(cabs) = 360, cabs = zero  #Always try to start at zero
          if interp_flg,
            [
            if abs(cuttype) = two, ppolar_fcyc
            ]
          else, xabs = abs(xabs)
          ]
        ]
      pfcalc

pxyzcout0       #Lathe and machine coordinates
      #This portion (tool_op$ = 202/203) is still the roughing cycle, 
      #we must replace X and Z at this time (before the spindle call)
      if tool_op$ = 202 | tool_op$ = 203 & gcode$ = 0 & org_x_pos & cutpos2$ = 4,     #CRF 
        [
        crf_line = fcc_subid
        size4 = rbuf(4,0)
        if crf_line <= size4, crf_xsav2 = rbuf(4,crf_line)
        if cutpos2$ = 4,       #if it's cutpos2$ = 4 (end of path) we want to add the move to the 
          [                    #pre canned cycle position but not replace the move from MP
          cfeed_x = crf_xsav2
          cfeed_z = crf_zsav2
          pax_shift
          prapidout
          ]
        if cutpos2$ = 0,       #Cutpos2$ = 0 is before an op, we want to replace the move from MP at this time
          [
          xa = crf_xsav2
          za = crf_zsav2
          ]
        ]
      #This portion (tool_op$ = 201) is now the finishing cycle, 
      #we must replace X and Z at this time so Mastercam's coordinates don't override our work
      if tool_op$ = 201 & gcode$ = 0 & org_x_pos,     #CRF 
        [
        crf_line = fcc_subid
        size4 = rbuf(4,0)
        if crf_line <= size4, crf_xsav2 = rbuf(4,crf_line)
        xa = crf_xsav2
        za = crf_zsav2
        ]
      cfeed_x = vequ(xa)
      csav = c$
      pax_shift
      ipr_type = zero

pxyzcout4       #Calculations for Y axis substitution (mapped)
      cfeed_x = xa + (rotdia$/two)
      cfeed_y = zero
      cfeed_z = za
      csav = ya * (360 / (pi$ * rotdia$))
      pax_shift
      if millcc, ipr_type = zero
      else, ipr_type = one

pxyzcout2       #Polar conversion, Cross cut, Right/Left Face cut
      #Drill polar is toolplane drilling toward center
      #if not a coincident axis (Face cut)
      if (y_axis | (opcode$ = three & abs(cuttype) <> two)), pxyzcout0
      else,
        [
        cfeed_x = sqrt(xa^2 + ya^2)
        cfeed_y = zero
        cfeed_z = za
        #if opcode$ = three & abs(cuttype) = three, csav = c$
        #else, csav = atan2(ya, xa) + c$
        if opcode$ = three & abs(cuttype) = three, csav = c$
        else,
          [
          if abs(cuttype) = 2, csav = atan2(ya, xa) + c$   #on the face you need to add c$ in case of twisted face plane
          else,
            [
            csav = c$         #cross cutting with rotary turned on (NOT AXIS SUB!)
            cfeed_y = ya      #C only indexes to plane and then Y motion
            ]
          ]
        pax_shift
        ipr_type = one
        if not(millcc & abs(cuttype) = two),
          [
          if fmtrnd(xa) = zero & fmtrnd(ya) = zero & opcode$ <> three,
            pnt_at_zero = one
          ]
        ]

pxyzcout5       #Multisurf rotary axis motion
      csav = atan2(vtooly$, vtoolz$)
      axisx$ = vequ(caxisx)
      xa = rotp (-csav, xa)
      cfeed_x = vequ(xa)
      pax_shift
      csav = csav + c$
      ipr_type = one

ppolar_fcyc     #Output values for face, polar conversion cycle
      xabs = (xa + dia_shift) * dia_mult
      yabs = zero
      zabs = (za + z_shift) * z_mult
      cabs = (ya + y_shift) * y_mult
      ipr_type = zero

pax_shift       #Apply multiplier and shift positions, csav was recalculated
      xabs = (cfeed_x + dia_shift) * dia_mult
      yabs = (cfeed_y + y_shift) * y_mult
      zabs = (cfeed_z + z_shift) * z_mult
      #Apply axis shift for lower turrets
      if posttype$ <> two & (lathtype = zero | lathtype = two),
        csav = csav + c_shift
      if posttype$ = two,
        [
        yabs = zero
        csav = zero
        ]

pplane_mod    #Modify the multiplier based on plane, see psw_str_mult
      if plane$ = zero,
        [
        dia_mult = prv_dia_mult * pl_ax_m0x
        y_mult = prv_y_mult * pl_ax_m0y
        z_mult = prv_z_mult * pl_ax_m0z
        ]
      else,
        [
        if plane$ = one,
          [
          dia_mult = prv_dia_mult * pl_ax_m1x
          y_mult = prv_y_mult * pl_ax_m1y
          z_mult = prv_z_mult * pl_ax_m1z
          ]
        else, #plane = two
          [
          dia_mult = prv_dia_mult * pl_ax_m2x
          y_mult = prv_y_mult * pl_ax_m2y
          z_mult = prv_z_mult * pl_ax_m2z
          ]
        ]

pcoutrev        #Rotary axis revolution calculation (Modify for wind-up)
      if cir_at_zero = one,
        [
        #Arcs at center position the c axis
        if cuttype =  -2| abs(cuttype) = three,
        csav = czero_csav - sweep$
        else, csav = czero_csav + sweep$
        ]
      #C does not move going to CL
      if pnt_at_zero, csav = last_csav
      cdelta = fmtrnd(csav) - last_csav  #This calculates once, for rev
      while abs(cdelta) > ctol, #If motion exceeds ctol, add wind-up
        [
        if cdelta > zero,
          [
          rev = rev - one
          cdelta = cdelta - 360
          ]
        else,
          [
          rev = rev + one
          cdelta = cdelta + 360
          ]
        ]

      if cwind & (toolchng | (toolchng0)), # & op_id$ <> last_op_id),   #add op_id$ <> last_op_id$ if you wish update the current after every chain/pass/depth
        [
        sav_rev = rev
        ]

      if cuttype <> four, c_wnd = rev * 360 + csav
      else, c_wnd = sav_rev * 360 + csav
      last_csav = csav
      @c_wnd
      #Now switch to c_wnd which is the absolute winding C calculation
      #Modify for shortest direction if toolchange or toolplane
      #but not with axis subs
      if c_axistype <> three,
        [
        if abs(prvc_wnd - c_wnd) > 180
          & (toolchng | (y_axis & cuttype < four)),
          [
          while abs(prvc_wnd - c_wnd) > 180,
            [
            if prvc_wnd > c_wnd, rev = rev + one
            else, rev = rev - one
            c_wnd = rev * 360 + csav
            ]
          @c_wnd
          ]
        ]

pindxcalc       #Index move calculations, direction is shortest exc. Asub
      if pnt_at_zero | cdelta = zero, indx_mc = prv_indx_mc
      else,
        [
        cdelta = fmtrnd(c_wnd) - prvc_wnd
        if cuttype = four, #Just look at the direction
          [
          if cdelta >= zero, indx_mc = one
          else, indx_mc = zero
          ]
        else,
          [
          #Phase shift delta 10 revolutions, check odd/even for direction
          if frac(int((cdelta + 3600)/180)/two), indx_mc = zero
          else, indx_mc = one
          ]
        ]
      #Set range 0-360
      while cabs < zero, cabs = cabs + 360
      while cabs > 360, cabs = cabs - 360

pfcalc          #Feedrate calculations, gcode 0 does not evaluate
      #if abs(c_wnd-prvc_wnd)<vtol$ | c_axistype=three | drillcur$          
      #wbt added c_resolution. Post must only enter pfclc_deg_inv if C motion >= to the resolution of the axis output occurs
      if abs(c_wnd-prvc_wnd) < c_resolution | c_axistype=three | drillcur$
      | ipr_type=zero | prv_pnt_at_zero | gcode$ = zero, pfcalc_u_min
      else, pfclc_deg_inv

pfcalc_u_min    #Feedrate unit/min
      feed = fr_pos$
      if feed > maxfeedpm, feed = maxfeedpm
      if posttype$ = 1 & mi6$ = 1, feed = feed/speed         #test whether or not feed/rev is working with dpm      
      prvfrdeg = feed

pfclc_deg_inv   #Feedrate deg/min, xa and ya are assumed relative to origin
      #Average last radius to current radius
      ldelta = ((cfeed_x+prv_cfeed_x)/two)^two+((cfeed_y+prv_cfeed_y)/two)^two
      circum = sqrt(ldelta) * two * pi$
      if circum = zero, circum = c9k          #Don't allow Zero
      ldelta = (cfeed_x-prv_cfeed_x)^two+(cfeed_y-prv_cfeed_y)^two
      ldelta = sqrt(ldelta+(cfeed_z-prv_cfeed_z)^two)
      cdelta = ((abs(c_wnd - prvc_wnd))/360)*circum
      if ldelta = zero, cldelta = cdelta
      else, cldelta = sqrt(cdelta^two + ldelta^two)
      if cldelta = zero, cldelta = c9k
      #Feedrate deg/min control and calculation
      frdeg = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
      if abs(frdeg - prvfrdeg) > frdegstp | ipr_type <> prv_ipr_type,
        [
        #Control output of frdeg
        prvfrdeg = frdeg
        feed = frdeg
        ]
      if fmtrnd(frdeg) = zero, feed = fr_pos$
      if frdeg > maxfrdeg, feed = maxfrdeg
      if posttype$ = 1 & mi6$ = 1, feed = feed/speed         #test whether or not feed/rev is working with dpm      

#Incremental calculations
ps_inc_calc     #Incremental calculations, start
      xia = fmtrnd(xabs)
      yia = fmtrnd(yabs)
      zia = fmtrnd(zabs)
      xinc = vsub (xia, prv_xia)
      if posttype$ <> two, ps_cinc_calc

ps_cinc_calc    #Incremental calculations, start rotary
      cia = fmtrnd(cabs)
      cinc = cia - prv_cia

pe_inc_calc     #Incremental calculations, end
      prvc_wnd = fmtrnd(c_wnd)      #Avoid updating until called explicitly
      !cfeed_x, !cfeed_y, !cfeed_z, !ipr_type  #These are used in pxyzcout
      !x$, !y$, !z$, !xa, !ya, !za
      !xia, !yia, !zia, !cia
      #!cc_pos$, !cutpos2     #01/23/04
      !cutpos2$     #01/23/04     #don't update cc_pos here as it doesn't allow for lathe cutter comp to function properly.

# --------------------------------------------------------------------------
# Mapping routines, maps input to basic machine coordinates (side view)
# --------------------------------------------------------------------------
pmatrix_su      #Setup mapping matrix
      hmtx1 = matt(m1$)
      hmtx1 = mmul(hmtx1, smtx1)
      if cuttype = one, mmtx1 = matt(m1$)
      if cuttype = two, mmtx1 = matt(smtx1)
      if cuttype =  -2,mmtx1 = matt(bmtx1)
      if cuttype = three | cuttype = five, mmtx1 = matt(cmtx1)
      if cuttype =  -3, mmtx1 = matt(crmtx1)
      if cuttype = four, mmtx1 = matt(amtx1)
      mmtx1 = mmul(mmtx1, smtx1)

pshft_map_xc    #Remove workshift and map to lathe coordinates, center
      xca = vadd (xc$, tox$)  #Always shift to origin
      if plane$ = one,
        [
        result = xca
        xca = zca
        zca = yca
        yca = result
        ]
      if plane$ = two,
        [
        result = yca
        yca = zca
        zca = result
        ]
      xca = vmap (xca, mmtx1)

pshft_map_ijk    #Remove workshift and map to lathe coordinates, ijk
      if arctype$ = one, #Absolute is shifted
        [
        if wcs_origin, iout = vadd (i$, tox$)
        else, iout = vequ (i$)
        ]
      else, iout = vequ (i$)
      iout = vmap (iout, mmtx1)

pshft_map_xa     #Remove workshift and map to lathe coordinates, xyz
      if wcs_origin, xa = vadd (copy_x, tox$)
      else, xa = vequ (copy_x)
      xa = vmap (xa, mmtx1)

pmap_home     #Set the location for home position
      xa = vequ(xh$)
      if map_home,
        [
        if wcs_origin, xa = vadd(xa, tox$)
        xa = vmap(xa, hmtx1)
        ]
      pplane_mod
      pxyzcout0 #basic toolplane positioning

pmap_plane    #Map NCI plane to machine plane
      mach_plane = plane$
      #Cross
      if cuttype=3 & plane$<two, mach_plane = abs(plane$ - one)
      #Top
      if (abs(cuttype)<=one | abs(cuttype)>=4),
      mach_plane = plane$ - one
      if mach_plane = m_one, mach_plane = two

# --------------------------------------------------------------------------
# NCI file pre-read look ahead routines
# Build the toolchange buffer, sets cycle and turret flags
# --------------------------------------------------------------------------
pwrttparam$      #Information from parameters
      #"pwrttparam", ~prmcode$, ~sparameter$, e$
      if prmcode$ = 15145, metvals   = rpar(sparameter$,1)
      if opcode$ = 104, result = fprm (opcode$)
      if prmcode$ = 15346, comp_type = rpar(sparameter$, 1)
      if prmcode$ = 20103, stinsert2 = sparameter$
      if prmcode$ = 20110, stholder2 = sparameter$

pwrtt$           #Buffer toolchange information, tooltable = 3 calls on 1003
      if gcode$ = 1001, psetup
      pcut_cctyp
      if opcode$=104 | opcode$=105 | opcode$=three | opcode$=16, cc_pos$ = zero
      if gcode$ <> 1001, plast_recd
      pcur_recd
      if gcode$ <> 1003, cc_pos$ = zero
      !opcode$, !tool_op$
      if gcode$ = 1003,
        [
        size1 = rbuf (one, zero)
        rc1 = one
        if rc1 < size1, preadcur_nxt
        if cc_1013$ = zero, cc_pos$ = zero
        ]

     if not(mult_spd_tl), [
      #if you want repetitive tool output, keep the abs( ) in ptooltable and remove the >= t$ from the pwrtt call to this block        
      if (tool_info = 2 | tool_info = 3) & gcode$ <> 1003 & op_id$ <> last_op_id & t$ >= 0, ptooltable]
      else, [
      last_op_id = op_id$
     stoolname=ucase(strtool$)
     wtl_n=abs(t$)
     wtr_n=spindle_no$
     pwritebuf]

#---------------------------------------------------------------------------------
#     Tool list variables
sb_name : ""

fbuf 5 0 2 0 0      # buffer tool numbers and turret numbers
fbuf 6 0 80 0 1     # buffer tool string

wtl_n       : 0     # write tool number
wtr_n       : 0     # write turret number
wc5         : 1
rc5       : 1
size5       : 0

wc6         : 1
rc6         : 1
b_tool      : 0
b_head      : 0

fmt "T" 4 b_tool

stoolname : ""          # tool name to read from the buffer 

match_not_found : yes$

test_tool   : 0

test_head   : 0

pwritebuf   # buffer out tool list
        rc5 = 1
       size5 = rbuf(5, 0)
        match_not_found = yes$
        while rc5 <= size5,
        [test_tool = rbuf(5, rc5)
        if test_tool = wtl_n & test_head = wtr_n, match_not_found = no$]
       if match_not_found,
        [wc5 = rc5
        wc6 = wc5
        wtl_n = wbuf(5,wc5)
        stoolname = wbuf(6,wc6)]

preadbuf    #Output Tool List
        spaces$ = 0
        size5 = rbuf(5, 0)
        rc5 = 1
        rc6 = 1
        while rc5 <= size5,   #2.13.06
        [b_tool = rbuf(5, rc5)
        sb_name = rbuf(6, rc6)
        n$, 32, "(", *b_tool, " - ", sb_name, [if b_head, " <SUB SPINDLE>"],")", e$]
        spaces$ = prv_spaces$
        sof_flg = 0

ptooltable # Write tool table, scans entire file, null tools are negative
           #if you want repetitive tool output, keep the abs( ) in ptooltable and remove the >= t$ from the pwrtt call to this block
           tnote = abs(t$)
           if opcode$ = 3 | opcode$ = 16, toffnote = tlngno$
           else, toffnote = tloffno$
           stinsert2 = ucase(stinsert2)
           !spaces$
           spaces$ = zero
           if posttype$ = 2,    #lathe tools
             [
             scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *toffnote, pdspace, " - ", *stinsert, *stinsert2, " - ", *stholder, *stholder2, scomm_end, e$
             #scomm_str, *tnote, ptspace, " - ", *toffnote, pdspace, " - ", *stinsert, *stinsert2, " - ", *stholder, *stholder2, scomm_end, e$
             ]
           else,                  #mill tools
             [
             if opcode$ = 3 | opcode$ = 16,
               [
               if tcr$ = 0, scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *tldianote, punit, pdiamspc, scomm_end, e$
               ]
             else,
               [
               if tcr$ > 0, scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *toffnote, pdspace, " - ", *tldianote, punit, pdiamspc, " - ", *tcr$,  punit, scomm_end, e$
               if tcr$ = 0, scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *toffnote, pdspace, " - ", *tldianote, punit, pdiamspc,  scomm_end, e$
               ]
             ]
           spaces$ = prv_spaces$

plistcomm  # Comments from tool library
           strtool$=ucase(strtool$)
           if strtool$=snull, strtool$ = snocomm
           *strtool$

           nstrlen = strlen(strtool$)
           counter = 1
           while counter <= (20-nstrlen), pspace

pspace     # Creates spaces based on tool comment length
           " "
           counter = counter + 1

ptspace    # Creates spaces based on tool number
           if t$ < 10, "  "
           if t$ >= 10 & t$ < 100, " "

pdspace    # Creates spaces based on diameter offset number
           if tloffno$ < 10, "  "
           if tloffno$ >= 10 & tloffno$ < 100, " "

pdiamspc   # Creates spaces based on diameter offset number
           #if tldia$ < 10, "  "        

punit      # Tool unit
           if met_tool$, "mm"
           else, 34

pcur_recd       #Write to the current tool record
      c1_gcode = gcode$
      pmatrix_su
      pset_turret
      pmap_home
      c1_xh = vequ(xabs)
      c1_tox = vmap (tox$, mmtx1)
      c1_cc_pos = cc_pos$
      if gcode$ <> 1003, c1_tool = abs(t$)
      else, c1_tool = zero
      c1_tloffno = tloffno$
      c1_maxss = maxss$
      c1_ss = abs(ss$)
      if cool_w_spd = zero, c1_spdir = spdir$ + one
      else, c1_spdir = (spdir$ + one) + (fsg2(coolant$) * three)
      c1_css_actv = css_actv$
      c1_fr_pos = fr_pos$
      c1_ipr_actv = ipr_actv$
      c1_coolant = coolant$
      c1_nextdc = nextdc$
      c1_posttype = posttype$
      c1_cuttype = cuttype
      c1_lathtype = lathtype
      c1_gcodecc = gcodecc
      c1_lathecc = lathecc
      c1_millcc = millcc
      c1_y_axis = y_axis
     c1_mr1 = mr1$
     c1_mr2 = mr2$
     c1_mr3 = mr3$
     c1_mr4 = mr4$

      if c1_posttype = 1, mt_flg = 1

      if opcode$ = 104,
        [
        if face_thd <> two, x_min$ = abs(xmaj_thd)
        else,
          [
          if abs(zstrt_thd) > abs(zend_thd), x_min$ = abs(zstrt_thd)
          else, x_min$ = abs(zend_thd)
          ]
        x_max$ = x_min$
        ]
      c1_spindle_no = spindle_no$
      c1_gcode = wbuf (one, wc1)

plast_recd      #Update the last record(s) for min-max and point
      rc1 = wc1 - one
      c1_gcode = rbuf (one, rc1)
      if prv_opcode$ <> 104,
        [
        c1_x_min = x_min$
        c1_x_max = x_max$
        ]
      rc1 = wc1 - one               #rc1 is used to write also
      c1_gcode = wbuf (one, rc1)

pcut_cctyp      #Find the type of cut for the tool buffer
                #y_axis
                #posttype
                #cuttype
                #lathtype
      y_axis = zero
      cuttype = zero
      if posttype$ = two, cuttype = one
      else,
        [
        if mill5$, cuttype = five
        else,
          [
          if rotary_type$ = one, cuttype = four
          else,
            [
            @m1$, @m2$, @m3$, @m7$, @m8$, @m9$
            if m7$ = m_one & m8$ = zero & m9$ = zero, cuttype =  -2
            if m7$ = one & m8$ = zero & m9$ = zero, cuttype = two
            if m1$ = m_one & m2$ = zero & m3$ = zero, cuttype = three
            if m1$ = one & m2$ = zero & m3$ = zero, cuttype =  -3
            if rotary_type$ = three | rotary_type$ = zero, y_axis = one
            ]
          ]
        ]
      lathtype = lturret$ + spindle_no$ * two
      #Check for errors
      if rotary_type$,
        [
        if (abs(cuttype) = two & rotary_axis$ <> three)
        | (abs(cuttype) = three & rotary_axis$ <> one),
          result = mprint(saxiserror)
        if cuttype = four & tlplnno$ <> one, result = mprint(stoperror)
        ]
      else,
        [
        if cuttype = zero, result = mprint(scutterror)
        ]
      #gcodecc, determine G74/G75 direction during processing
      #lathecc
      #millcc
      gcodecc = zero
      lathecc = zero
      if tool_op$ > 201,
        [
        if tool_op$ = 202 | tool_op$ = 203,
          [
          gcodecc = one
          lathecc = one
          if tool_op$ = 203, lathecc = m_one
          ]
        else,
          [
          if tool_op$ = 204 | tool_op$ = 205,
            [
            gcodecc = two
            lathecc = one
            if tool_op$ = 205, lathecc = m_one
            ]
          else,
            [
            if tool_op$ = 206 | tool_op$ = 207,
              [
              gcodecc = three
              lathecc = two
              if tool_op$ = 207, lathecc =  -2
              ]
            else,
              [
              if tool_op$ = 208,
                [
                gcodecc = four
                lathecc = three
                ]
              ]
            ]
          ]
        ]
      if mi4$<>zero & opcode$ <> three & (cuttype=four | abs(cuttype)=two),
         millcc = mi4$
      else, millcc = zero

psetup          #Setup post based on NCI settings
      sbufname3$ = spathnci$ + snamenci$ + sextext$
      spathext$ = spathnci$
      snameext$ = snamenci$
      #Set metric defaults
      if met_tool$ = one,
        [
        conversion = 1000
        vtol$ = vtol_m
        maxfeedpm = maxfeedpm_m
        lcc_move = lcc_move_m
        ]
      #Setup for old or new style canned cycles
      if old_new_sw = one,
        [
        result = newfs (16, thddepth$)
        result = newfs (16, thdfirst$)
        ]
      else,
        [
        result = nwadrs (stra, thdang)
        result = nwadrs (stri, thdrdlt)
        result = nwadrs (strk, thddepth$)
        result = nwadrs (strd, thdfirst$)
        #Lathe canned cycle old style conversion
        result = nwadrs (strd, depthcc)
        result = nwadrs (strd, ncutscc)
        result = nwadrs (stri, g73x)
        result = nwadrs (strk, g73z)
        result = nwadrs (stri, grvspcc)
        result = nwadrs (strk, grvdpcc)
        ]
      result = nwadrs(str_cax_abs, cabs)
      result = nwadrs(str_cax_inc, cinc)
      result = nwadrs(str_index, indx_out)
      sc_minus = str_cax_abs + sc_minus
      breakarcss = breakarcs$

# --------------------------------------------------------------------------
# Turret and cut type change setup, do not edit
# --------------------------------------------------------------------------
pset_turret     #Set the machine conditions and mapping based on the turret
      if lathtype = one | use_only_tl, pltype1
      else,
        [
        if lathtype = zero, pltype0
        else,
          [
          if lathtype = two, pltype2
          else, pltype3
          ]
        ]
      psw_str_mult

pltype0         #Bottom turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl0
        min_speed = min_speedl0
        sw_string = scase_bl_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm0
        min_speed = min_speedm0
        sw_string = scase_bl_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_bl_c_2
        if cuttype = three, sw_string = scase_bl_c3
        if cuttype = -3, sw_string = scase_bl_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_bl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_bl_c4
        if cuttype = five, sw_string = scase_bl_c5
        ]

pltype1         #Top turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl1
        min_speed = min_speedl1
        sw_string = scase_tl_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm1
        min_speed = min_speedm1
        sw_string = scase_tl_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_tl_c_2
        if cuttype = three, sw_string = scase_tl_c3
        if cuttype = -3, sw_string = scase_tl_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tl_c4
        if cuttype = five, sw_string = scase_tl_c5
        ]

pltype2         #Bottom turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl2
        min_speed = min_speedl2
        sw_string = scase_br_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm2
        min_speed = min_speedm2
        sw_string = scase_br_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_br_c_2
        if cuttype = three, sw_string = scase_br_c3
        if cuttype = -3, sw_string = scase_br_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_br_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_br_c4
        if cuttype = five, sw_string = scase_br_c5
        ]

pltype3         #Top turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl3
        min_speed = min_speedl3
        sw_string = scase_tr_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm3
        min_speed = min_speedm3
        sw_string = scase_tr_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_tr_c_2
        if cuttype = three, sw_string = scase_tr_c3
        if cuttype = -3, sw_string = scase_tr_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tr_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tr_c4
        if cuttype = five, sw_string = scase_tr_c5
        ]

psw_str_mult    #Apply sw_string to variables and strings
      #c axis type
      #c_axistype = plcval (sw_string, 8)    #c_axistype comes from machine def
      if rot_index = 1, c_axistype = 3
      else,
        [
        if rot_type = 0 | rot_type = 2, c_axistype = 1
        if rot_type = 1, c_axistype = 2
        ]
      #reverse spindle
      spd_rev = plcval (sw_string, 7)
      #plane 0
      rslt_plc = plcval (sw_string, 6)
      if rslt_plc = zero,
        [
        sg02 = sxg02
        sg03 = sxg03
        sg41 = sxg41
        sg42 = sxg42
        ]
      else,
        [
        sg02 = sxg03
        sg03 = sxg02
        sg41 = sxg42
        sg42 = sxg41
        ]
      #plane 1
      rslt_plc = plcval (sw_string, five)
      if rslt_plc = zero,
        [
        sg02_1 = sxg02
        sg03_1 = sxg03
        sg41_1 = sxg41
        sg42_1 = sxg42
        ]
      else,
        [
        sg02_1 = sxg03
        sg03_1 = sxg02
        sg41_1 = sxg42
        sg42_1 = sxg41
        ]
      #plane 2
      rslt_plc = plcval (sw_string, four)
      if rslt_plc = zero,
        [
        sg02_2 = sxg02
        sg03_2 = sxg03
        sg41_2 = sxg41
        sg42_2 = sxg42
        ]
      else,
        [
        sg02_2 = sxg03
        sg03_2 = sxg02
        sg41_2 = sxg42
        sg42_2 = sxg41
        ]
      #plane 0
      rslt_plc = plcval (sw_string, three)
      rslt_upd = updstr (swstr)
      sg17 = swstr
      #plane 1
      rslt_plc = plcval (sw_string, two)
      rslt_upd = updstr (swstr)
      sg19 = swstr
      #plane 2
      rslt_plc = plcval (sw_string, one)
      rslt_upd = updstr (swstr)
      sg18 = swstr
      #plane 0, x axis
      rslt_plc = plcval (sw_string, m_one)
      pl_ax_m0x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -2)
      pl_ax_m0y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -3)
      pl_ax_m0z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -4)
      pl_ax_m1x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -5)
      pl_ax_m1y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -6)
      pl_ax_m1z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -7)
      pl_ax_m2x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -8)
      pl_ax_m2y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -9)
      pl_ax_m2z = -((rslt_plc * two) - one)

psubspd      #Ltlchg$ Routine for Sub spindle Machines
     if nextdc$ <> 6,[
      mr_ttl = abs(mr1$) + abs(mr2$)
      if not(mr_ttl),[
      pspindle
      if css_actv$,
      [if css_start_rpm, prpm
      else,pcssg50, pcss]
      else,prpm]
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero

      if mr_ttl & tool_op$ = 67,[
      pick_flg = 1
      pcan1, pbld, n$, *sgcode, pfzout, e$
      if abs(mr4$),[n$, "P0.", "M119", e$
      "sub ", n$, *mr4$, "M19", e$]
      n$, *sm05, e$
      n$, *sunclmp_sub, e$
      n$, "G0", "G58", *mr1$, e$

       speed = c1_ss
       n$, *speed, *spindle_l, e$
       result = nwadrs(strp, speed)
       n$, *speed, *spindle_ls, e$

      n$, "G98", e$
      n$, "G01", *mr2$, "F50.", e$

      n$, *sclmp_sub, e$
      n$, "G04 P2.", e$

      if mr3$ & tool_op$ = 67,[ #misc value stock advance for part off
      n$, *sunclmp_main, e$
      n$, "G01", *mr3$, "F50.", e$
      n$, *sclmp_main, e$]]

    if mr_ttl & tool_op$ = 67,[
    if sp_rpm < 0, [
    result = nwadrs(strp, speed)
     n$, ~speed, e$
    result = nwadrs(strs, speed)]
     pspindle

      sav_absinc = absinc$
      if home_type > one, absinc$ = zero]
      else,[
      if bar_flg, pbar_feed
      else,  pcan1, pbld, n$, *sgcode, pfxout, pyout, pfzout, pscool, strcantext, e$]
      ]

psnglspd         # Ltlchg$ Routine for Sindle Spindle Machines
      if nextdc$ <> 6, [
     if sp_rpm < 0, [                           #5/29/08
     result = nwadrs(strp, speed)       #5/29/08
     n$, ~speed, e$                         #5/29/08
     result = nwadrs(strs, speed)]  #5/29/08
      pspindle
      #Added for 'css_start_rpm' logic (09/05/01)
      if css_actv$,
        [
        if css_start_rpm,
          prpm # Direct RPM startup for programmed CSS
        else,
          pcssg50, pcss # NO RPM start - just output the CSS
        ]
      else, # Direct RPM was programmed
        [
        prpm # Output programmed RPM
        ]
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      if bar_flg, pbar_feed  #5/29/08
      else, [ pcan1, pbld, n$, *sgcode, pfxout, pyout, e$
     pcan1, pbld, n$, pfzout, pscool, strcantext, e$ ]
     ]
# --------------------------------------------------------------------------
# Post Text --  Use Control Definition Manager to modify
# --------------------------------------------------------------------------
[CTRL_MT_MILL|SOMEC_EXCEL V4]
[misc integers]
1. ""
2. ""
3. ""
4. "Mill Cyc G107/G112 [0=OFF,1=ON]"
5. "Synch Spindles [0=OFF,1=ON]"
6. "Feed/Rev [0=OFF,1=ON]"
7. "Clamp [1=CLAMP,2=BRAKE,3=OFF]"
8. ""
9. ""
10. "Parts Catcher [0=OFF,1=ON]"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Drill/Counterbore - G83/G87"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Peck Drill - longhand"
7. ""
8. ""
9. ""
10. ""
11. ""
[chip break]
1. "Drill/Peck - G83/G87"
7. "Peck"
8. ""
9. ""
10. ""
11. ""
[tap]
1. "Tapping - G84/G88"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Boring - G85/G89"
7. ""
8. ""
9. ""
10. ""
[bore2]
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
8. ""
9. ""
10. ""
[drill cycle descriptions]
1. "Drill/Counterbore - G83/G87"
2. "Peck Drill - longhand"
3. "Drill/Peck - G83/G87"
4. "Tapping - G84/G88"
5. "Boring - G85/G89"
[canned text]
1. "Program Stop"
2. "Optional Stop"
3. "Block Delete on"
4. "Block Delete off"
5. "Return Tailstock"
6. "Advance Tailstock"
7. "Return Chute"
8. "Advance Chute"
9. "Exact Stop on"
10. "Exact Stop off"
[CTRL_MT_LATHE|SOMEC_EXCEL V4]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. "Synch Spindles [0=OFF,1=ON]"
6. ""
7. ""
8. ""
9. ""
10. "Parts Catcher [0=OFF,1=ON]"
[misc reals]
1. "'"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Drill/Counterbore - G83"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Peck Drill - longhand"
7. "Peck"
8. ""
9. ""
10. ""
11. ""
[chip break]
1. "Drill/Peck - G83"
7. "Peck"
8. ""
9. ""
10. ""
11. ""
[tap]
1. "Tapping - G84"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
7. ""
8. ""
9. ""
10. ""
[bore2]
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
1. "Bar Stop"
3. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle descriptions]
1. "Drill/Counterbore - G83"
2. "Peck Drill - longhand"
3. "Drill/Peck - G83"
4. "Tapping - G84"
7. "Bar Stop"
[stock transfer custom parameters]
1. "Cutoff Tool? [0=no output]"
2. "Use Torque Skip?"
11. "Rapid Position"
12. "Feed Position"
13. "Tool Initial Position"
[CTRL_MT_MILL|SOMEC_EXCEL]
[misc integers]
1. ""
2. ""
3. ""
4. "Mill Cyc G107/G112 [0=OFF,1=ON]"
5. "Synch Spindles [0=OFF,1=ON]"
6. "Feed/Rev [0=OFF,1=ON]"
7. "Clamp [1=CLAMP,2=BRAKE,3=OFF]"
8. ""
9. ""
10. "Parts Catcher [0=OFF,1=ON]"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Drill/Counterbore - G83/G87"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Peck Drill - longhand"
7. ""
8. ""
9. ""
10. ""
11. ""
[chip break]
1. "Drill/Peck - G83/G87"
7. "Peck"
8. ""
9. ""
10. ""
11. ""
[tap]
1. "Tapping - G84/G88"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Boring - G85/G89"
7. ""
8. ""
9. ""
10. ""
[bore2]
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
8. ""
9. ""
10. ""
[drill cycle descriptions]
1. "Drill/Counterbore - G83/G87"
2. "Peck Drill - longhand"
3. "Drill/Peck - G83/G87"
4. "Tapping - G84/G88"
5. "Boring - G85/G89"
[canned text]
1. "Program Stop"
2. "Optional Stop"
3. "Block Delete on"
4. "Block Delete off"
5. "Return Tailstock"
6. "Advance Tailstock"
7. "Return Chute"
8. "Advance Chute"
9. "Exact Stop on"
10. "Exact Stop off"
[CTRL_MT_LATHE|SOMEC_EXCEL]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. "Synch Spindles [0=OFF,1=ON]"
6. ""
7. ""
8. ""
9. ""
10. "Parts Catcher [0=OFF,1=ON]"
[misc reals]
1. "'"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Drill/Counterbore - G83"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Peck Drill - longhand"
7. "Peck"
8. ""
9. ""
10. ""
11. ""
[chip break]
1. "Drill/Peck - G83"
7. "Peck"
8. ""
9. ""
10. ""
11. ""
[tap]
1. "Tapping - G84"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
7. ""
8. ""
9. ""
10. ""
[bore2]
7. ""
8. ""
9. ""
10. ""
11. ""
[misc1]
1. "Bar Stop"
3. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle descriptions]
1. "Drill/Counterbore - G83"
2. "Peck Drill - longhand"
3. "Drill/Peck - G83"
4. "Tapping - G84"
7. "Bar Stop"
[stock transfer custom parameters]
1. "Cutoff Tool? [0=no output]"
2. "Use Torque Skip?"
11. "Rapid Position"
12. "Feed Position"
13. "Tool Initial Position"
[CTRL_TEXT_END]
